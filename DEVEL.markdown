RSpec Install
=============

After initial bundle install, need to do an explicit rspec install:

```
rails generate rspec:install
```

which creates the rspec dir.

Static Pages
============
Following Ryan Bates' method, used his nifty-generators (installed via
a ruby gem) to produce a Page
model:

```
rails generate nifty:scaffold Page name:string permalink:string content:text
```

Also installed the RedCloth gem in the Gemfile:

```
gem 'RedCloth'
```

which allows administrators to use the Textile markup language in their
static pages.

Used the carrierwave gem to facilitate file upload (the rmagick gem is
also useful when using carrierwave (we'll use it to auto-generate thumbnail
images when the full images are uploaded):

```
gem "rmagick"
gem "carrierwave"
```

Then created a carrierwave uploader called Document:

```
rails g uploader Document
```

A new model called Asset was created for explicitly uploading files:

```
rails g nifty:scaffold Asset document:string description:text
```

The Sample Model
================
The model requires barcode generation for which the ruby gem 'barby'
is used. Note that there is a problem with the other well-known barcode
generator based on gnu barcode. 'barby' is self-contained and doesn't need
anything else - it's pure ruby. 


The sample model contains the following parts:

code        This is autogenerated and takes the form AAA-AA-YY-1111 where
            the AAA and AA represent 3 letter codes for group and submitter
            respectively; the YY represents the year and the 1111 represents
            a number which is incremented for that group but reset to
            zero at the start of each calendar year. [string]

cif	    The proposed chemical formula in cif format. [string]

synth	    The synthetic route. This will be usually a chemdraw file or
            possibly an image file specifying the details of the synthesis.
            This will rely on a carrierwave uploader called Synth. [string]

coshh_name  Name of solvent (if any). [string]

coshh_desc  Brief description of sample (e.g. organic amide) [string]

coshh_info  List of any known hazards and procedures in case of contact. [text]

coshh_haz   Chemical hazard information. This will take the form
            of a list selected from checkboxes. The checkboxes will be
            generated from a separate chemical hazard table. [string]

params      Unit cell parameters or CSD/Newcastle code for possible 
            by-products or previously obtained, unpublished results. [string]

status      The status flag of the sample. This can be changed only by
            crystallography staff and initially will have the value
            'SUBMITTED'. Probably best if other values are selected from
            a drop-down list generated from a status flags table. It is
            hidden on the form (but should appear in the show/edit
            views). [string]

priority    User-defined priority number in case of multiple sample
            submissions. [integer]

powd        Is powder diffraction required yes/no. [boolean]

chiral      Is molecule chiral? yes/no. [boolean]

cost_code   This will be set by crystallography staff and allocated by
            finance staff. It is hidden on the form and will be blank
            by default but will be visible in show/edit views. [string]

barcode     An auto-generated barcode. This will use the ruby gem
            'barby'. [string]

Again, use nifty-generators to generate the sample model:

```
rails generate nifty:scaffold Sample code:string cif:string synth:string coshh_name:string coshh_desc:string coshh_info:text coshh_haz:string params:string status:string priority:integer powd:boolean chiral:boolean cost_code:string barcode:string
```

don't forget to migrate the database:

```
rake db:migrate
```

Create the carrierwave uploader for synthetic route file:

```
rails g uploader Synth
```

Edit the /app/models/sample.rb file and add the line:

```
mount_uploader :synth, SynthUploader
```

this links the synth field with the carrierwave fileuploader.

Then change the new sample form code. First need to make the form multipart
because we're uploading an external file along with the other data:

```
<%= form_for @sample, :html => {:multipart => true} do |f| %>
```

and also change the text box entry for the synth field to a file selection box:

```
<%= f.file_field :document %>
```

Chemical Hazard Codes
=====================
Each sample can be associated with zero or more chemical hazard codes
and vice-versa (i.e. a many-to-many relationship). 
Potentially, these codes could vary
and new ones could come in, so we create a small table for this.
The table has two fields: hazard_desc and hazard_abbr the second field
being the standard abbreviation of the first.
As before, use nifty generators for this:

```
rails generate nifty:scaffold Hazard hazard_desc:string hazard_abbr:string
```

This unfortunately means that we need to alter the sample table because
coshh_haz doesn't need to be there - rails3 will handle the many-to-many
association for us.
Do this with a migration:

```
rails generate migration remove_hazard_from_sample
```

Edit the migration to contain the following code:

```
class RemoveHazardFromSample < ActiveRecord::Migration
  def self.up
    remove_column :samples, :coshh_haz
  end

  def self.down
    add_column :samples, :coshh_haz, :string
  end
end
```

We must also set up a join table via another migration:

```
rails generate migration create_samples_hazards
```

with the following content:

```
class CreateSamplesHazards < ActiveRecord::Migration
  def self.up
    create_table :hazards_samples, :id => false do |t|
      t.references :sample, :null => false
      t.references :hazard, :null => false
    end
  end

  def self.down
    drop_table :hazards_samples
  end
end
```

Also, we need the following entries in the sample and hazard models
respectively (the files sample.rb and hazard.rb in app/models):

```
  has_and_belongs_to_many :hazards # sample.rb

  has_and_belongs_to_many :samples # hazard.rb
```

In the sample form, we can now add a set of checkboxes thus:

```
    <% for hazard in Hazard.find(:all) %>
    <div>
      <%= check_box_tag "sample[hazard_ids][]", hazard.id, @sample.hazards.include?(hazard) %>
      <%= hazard.hazard_desc %>
    </div>
    <% end %>
```

NOTE: for the above to work, you need to set :hazard_ids in the
attr_accessible flag of the sample model:

```
class Sample < ActiveRecord::Base
  attr_accessible :hazard_ids, :code, :cif, :synth, :coshh_name, :coshh_desc, :coshh_info, :coshh_haz, :params, :status, :priority, :powd, :chiral, :cost_code, :barcode
  has_and_belongs_to_many :hazards
```

if you don't add :hazard_ids as attr_accessible then you'll get the
following error in the server log:

```
WARNING: Can't mass-assign protected attributes: hazard_ids
```

Image Processing
================
When images of synthetic routes are uploaded, we want to generate a
thumbnail version (while still retaining the original) and display the
thumbnail on the show page but which is hyperlinked to the full image.
To do this, we need rmagick (which is installed via a gem as described
earlier). Then we edit the carrierwave uploader class file in:

```
app/uploaders/image_uploader.rb
```

and edit/uncomment the thumbnail code already there to:

```
  version :thumb do
    process :resize_to_limit => [320, 240]
  end
```

this uses rmagick to resize the original image into a thumbnail version
for display. You will also need to uncomment the RMagick include statement
near the top of the app/uploaders/image_uploader.rb file.

```
  include CarrierWave::RMagick
```

Displaying the Barcode Graphic
==============================

Decided to use the Code39 standard. Need to first create a special
inline controller to actually display the barcode graphic (png). So, we
have this in the samples controller:

```
  def show_barcode

    require 'barby'
    require 'barby/barcode/code_39'
    require 'barby/outputter/png_outputter'
    #require 'barby/outputter/ascii_outputter'
    @sample = Sample.find(params[:id])

    barcode = Barby::Code39.new(@sample.barcode)

    # puts barcode.to_ascii #Implicitly uses the AsciiOutputter

    bcimage = barcode.to_png

    send_data bcimage, :type => 'image/png', :disposition => 'inline'

  end
```

We then have the following code in the samples 'show' view:

```
  <strong>Barcode:</strong>
  <%= @sample.barcode %><br />
  <%= image_tag url_for(:controller => "samples", :action => "show_barcode", :id => @sample.id) %>
```

We also need a route for this controller in config/routes.rb:

```
  match ':controller/:action/:id'
```

Create Table for Research Groups
================================
Here, we create a table for research groups (or any other groups) which
users will ultimately be linked with.

```
rails generate nifty:scaffold Group group_abbr:string group_desc:string
```

Now we want to limit the abbreviation string to 3 characters so we
create a new migration:

```
rails generate migration limit_group_abb
```

Then edit the migration file to contain:

```
class LimitGroupAbb < ActiveRecord::Migration
  def self.up
    change_column :groups, :group_abbr, :string, :limit => 3
  end

  def self.down
    change_column :groups, :group_abbr, :string, :limit => 255
  end
end
```

Add some validations for the group abbreviation:

```
  validates :group_abbr, :length => { :is => 3 }, :uniqueness => true
  validates :group_desc, :presence => true
  validates_format_of :group_abbr, :with => /[A-Z]{3}/
```

this restricts the abbreviation to a 3-capital letter unique string.

PDF Generation
==============

Decided to use PDFkit for this. First installed wkhtmltopdf by downloading
a static executable from the website and copying to /usr/local/bin and
/usr/bin (just to be sure). Next the Gemfile for PDFKit:

```
gem "pdfkit"
```

After the usual `bundle install`, added a line near the end of
the file `config/application.rb`:

```
    config.filter_parameters += [:password]
    config.middleware.use "PDFKit::Middleware"
  end
end
```

Then did a `rake middleware` to check that PDFKit was installed
correctly. Now, appending `.pdf` to a URL will render a PDF version
of that page. Unfortunately you can really only check this in production
mode because WEBrick is single-threaded (and still just displays the HTML).
You can test that the URL is accepted by the server however, even if it
doesn't display the HTML.

User Authentication with Devise
===============================
Followed Ryan Bates Railscast example. Added

```
gem 'devise', '1.4.9'
```

and then did a `bundle install` followed by:

```
rails generate devise:install
```

note colon rather than underscore in the above command.
Then needed to add the following to the development environment file
`config/environments/development.rb`:

```
config.action_mailer.default_url_options = { :host => 'localhost:3000' }
```

For production, need to add a similar line to the
`config/environments/production.rb` file, but with the name of the
actual machine replacing the `localhost:3000` bit. You must also set an
explicit @root_url@ in the `config/routes.rb` file such as:

```
root :to => "pages#home"
```

For this to work, also created a home controller action for the page model
in `app/controllers/pages_controller.rb` (initially using the 'about'
permalink but eventually this will be the 'home' permalink:

```
  def home
    @page = Page.find_by_permalink('about')
  end
```

and a view in `app/views/pages/home.html.erb` - this was almost identical to
the 'show' action view.

Also need to ensure you have flash messages in 
`app/views/layouts/application.html.erb`, e.g.:

```
<p class="notice"><%= notice %></p>
<p class="alert"><%= alert %></p>
```

This is achieved in the current application via some general flash code
in the view template (`app/views/layouts/application.html.erb`):

```
<% flash.each do |name, msg| %>
  <%= content_tag :div, msg, :id => "flash_#{name}" %>
<% end %>
```

After this, followed the user setup as explained by Ryan Bates (the devise 
docs also have clear instructions on how to do this).

Defining the User and Group Relationship
========================================
We need a one-to-many relationship between groups and users (a group has 
many users, but a user belongs to just one group. 
First, we must add a group_id integer field to the user model by creating
a migration as follows:

```
rails generate migration add_group_id_to_users group_id:integer
```

Also, we need the following entries in the user and group models
respectively (the files user.rb and group.rb in app/models):

```
  has_many :users # group.rb

  belongs_to :group # user.rb
```

The group_id field must be made accessible in the user model:

```
attr_accessible :email, :password, :password_confirmation, :remember_me, :group_id
```

We need to customise views in devise, so we first ask devise to generate files
for its default views (which are normally stored in the devise 'engine':

```
rails generate devise:views
```

This creates a lot of views which we can now edit to include groups.
The first files to change are the new user registration form and edit form:

```
app/views/devise/registrations/new.html.erb
app/views/devise/registrations/edit.html.erb
```

In the user form, we can now add a group select dropdown thus ( note that
the call to select is NOT preceded by the form object reference, i.e.
not f.select just select):

```
  <div><%= f.label "Group" %><br />
  <%= select(:user, :group_id, Group.all.collect {|g| [ g.group_desc, g.id ] },
    {:include_blank => 'None'}) %></div>
```

Modifying the User Model
========================
Needed to add a few more fields to the devise user model. First added a
boolean 'admin' field to denote whether a user is an administrator.
Did this via a migration as usual:

```
rails generate migration add_admin_to_user admin:boolean
```

Wanted to make the default for this @false@ so modified the migration
file by adding a `:default => false` directive to `add-column`:

```
class AddAdminToUser < ActiveRecord::Migration
  def self.up
    add_column :users, :admin, :boolean, :default => false
  end

  def self.down
    remove_column :users, :admin
  end
end
```

Then did a `rake db:migrate` and restarted the server. Then did a similar
thing to add `firstname` and `lastname` text fields. After this, edited
the user model file to make these new fields attribute accessible
in `app/models/user.rb`:

```
class User < ActiveRecord::Base
  # Include default devise modules. Others available are:
  # :token_authenticatable, :encryptable, :confirmable, :lockable, :timeoutable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable

  # Setup accessible (or protected) attributes for your model
  attr_accessible :email, :password, :password_confirmation, :remember_me, :group_id, :firstname, :lastname, :admin
end
```

Unfortunately, attempting to regenerate the devise views with:

```
rails generate devise:views
```

doesn't add entries for the new fields. Worse, it deletes the references
to the user group in the existing forms as created previously. Hence,
the new fields needed to be added to the forms:

```
  <div><%= f.label 'First Name' %><br />
  <%= f.text_field :firstname %></div>

  <div><%= f.label 'Last Name' %><br />
  <%= f.text_field :lastname %></div>
```

Note that the admin entry was not added, since it defaults to `false`.
It will (eventually) be available only for an administrator to edit.
The group reference was reinstated as before.

Defining the Sample and User Relationship
========================================
We need a one-to-many relationship between users and samples (a user has
many samples, but a sample belongs to just one user).
First, we must add a user_id integer field to the sample model by creating
a migration as follows:

```
rails generate migration add_user_id_to_samples user_id:integer
```

Also, we need the following entries in the sample and user models
respectively (the files sample.rb and user.rb in app/models):

```
  has_many :samples # user.rb

  belongs_to :user # sample.rb
```

The user_id field must be made accessible in the sample model:

```
  attr_accessible :hazard_ids, :code, :cif, :synth, :coshh_name, :coshh_desc, 
                  :coshh_info, :coshh_haz, :params, :status, :priority, 
                  :powd, :chiral, :cost_code, :barcode, :user_id
```

When creating a sample, the user is associated with it via this simple
piece of code in the create function of the sample controller (note the
current_user function supplied by devise):

```
  def create
    # @sample = Sample.new(params[:sample])
    @sample = current_user.samples.build params[:sample]
    if @sample.save
      redirect_to @sample, :notice => "Successfully created sample."
    else
      render :action => 'new'
    end
  end
```

Basic Refinement of Views
=========================
Next, refine some of the views. For example, the samples index really
needs to show only a few basic things - so we strip off things such
as the reaction pathway image and add a column to show the user who
submitted the sample and his research group.
It is easy to add a link to a user and group in the main samples index:

```
<td><%= "#{sample.user.firstname} #{sample.user.lastname}"  %></td>
<td><%= "#{sample.user.group.group_desc}"  %></td>
```

Auto-Generation of Sample Code
==============================
Neede to auto-generate the sample code string which takes the following format:

```
AAA-AA-YY-1111
```

the AAA represent 3 letter codes for supervisor and submitter
respectively; the YY represents the year and the 1111 represents
a number which is incremented for that supervisor but reset to
zero at the start of each calendar year. The AAA part is taken from the
three letter group abbreviation and the AA part is taken from the
user initials. the year is trivial and a bit of code is needed to generate
the 4-digit trailing number. The code to do this goes in the controller
rather than the model, since it relies on pulling information from the
user and group tables. Here is the code in the samples controller file:

```
  def make_sample_code
    x = Time.now
    grp = current_user.group.group_abbr
    usr = current_user.firstname.first.upcase +
           current_user.lastname.first.upcase
    yr  = x.strftime('%g')
    num = create_sample_num
    "#{grp}-#{usr}-#{yr}-#{num}"
  end

  def create_sample_num
    x = Time.now
    yr = x.strftime('%g')
    grp = current_user.group.group_abbr
    samps = Sample.where('code LIKE ?', "#{grp}-%-#{yr}-%").all
    if (samps.length > 0)
      str = samps.last.code
      last_num = /\d\d\d\d$/.match(str)[0].to_i
      new_num = last_num + 1
      # now an amazing idiom to convert to 4 digit string!
      return "%04d" % new_num
    else
      return "%04d" % 1
    end
  end
```

These functions are then used later in the 'new' function:

```
  def new
    @sample = Sample.new
    @sample.code = make_sample_code
  end
```

View and Controller Permissions: Making a Start
===============================================

First, we change the permissions on the semi-static pages by making the
Edit/Destroy etc links disappear for all users (whether signed-in or not)
except when a user is signed in and is an administrator. This needs only
to be done for the @home.html.erb@ and @show.html.erb@ views.
Here's the code we use:

```
<% if user_signed_in? %>

<% if current_user.admin? %>
<p>
  <%= link_to "Edit", edit_page_path(@page) %> |
  <%= link_to "Destroy", @page, :confirm => 'Are you sure?', :method => :delete %> |
  <%= link_to "View All", pages_path %> |
  <%= link_to "Input Help", "http://en.wikipedia.org/wiki/Textile_%28markup_language%29", :target => "_blank" %>
</p>

<% else %>
<p>
</p>
<% end %>

<% end %>
```

Of course, this just prevents the links being seen --- we still need to
protect the controllers. Do this by defining a before filter
called @admin_required@ in the @application_controller.rb@ file:

```
  def admin_required
    return true if user_signed_in? and current_user.admin?
    session[:return_to] = request.request_uri
    redirect_to root_url,
             :alert => 
             "You must be an administrator to do this!" and return false
  end
```

We then make use of this in the pages controller file:

```
  before_filter :admin_required, :only => [ :new, :create, :index, :edit,
                                            :update, :destroy ]
```

In this way, we protect the semi-static pages from being edited
by an unauthorized user.

Setting up a Status Flag Table
==============================
It was decided to set up a special table to hold status flag strings. The
table is very simple, consisting of a string field and a text field
to hold the status flag and some brief explanatory text.
As usual, RB's nifty generators were used:

```
rails generate nifty:scaffold Flag name:string description:text
```

We need a one-to-many relationship between status flags and samples 
(a flag can be associated with many samples, but a sample has just one 
status flag at any one time.
First, we must add a flag_id integer field to the sample model by creating
a migration as follows:

```
rails generate migration add_flag_id_to_samples flag_id:integer
```

Also, we need the following entries in the sample and flag models
respectively (the files sample.rb and flag.rb in app/models):

```
  has_many :samples # flag.rb

  belongs_to :flag # sample.rb
```
We now remove @:status@ from the attr_accessible flag of the sample model
as well as its validation line from @app/models/sample.rb@.
Of course, we must now also remove the status field from the sample model.
Do this with a migration:

```
rails generate migration remove_status_from_sample
```

Edit the migration to contain the following code:

```
class RemoveHazardFromSample < ActiveRecord::Migration
  def self.up
    remove_column :samples, :status
  end

  def self.down
    add_column :samples, :status, :string
  end
end
```

Forcing a Default Status Flag for a New Sample
==============================================
This seemed a sensible thing to do, so a migration was applied. The
migration file had the following content:

```
class AddDefaultValueForStatusToSample < ActiveRecord::Migration
  def self.up
    change_column :samples, :flag_id, :integer, :default => 1, :null => false
  end

  def self.down
    change_column :samples, :flag_id, :integer
  end
end
```

Adding User sample Listing on Edit User Page
===========================================
This is achieved by editing the @app/views/devise/registrations/edit.html.erb@
page with the following code:

```
<h3><%="My Samples" %></h3>

<table>
  <tr>
    <th>Code</th>
    <th>Params</th>
    <th>Status</th>
    <th>Update</th>
    <th>Priority</th>
    <th>Powd</th>
    <th>Chiral</th>
    <th>Cost Code</th>
    <th>Group</th>
  </tr>
  <% for sample in @user.samples %>
    <tr>
      <td><%= sample.code %></td>
      <td><%= sample.params %></td>
      <td><%= sample.flag.name %></td>
      <td><%= sample.updated_at %></td>
      <td><%= sample.priority %></td>
      <td><%= sample.powd %></td>
      <td><%= sample.chiral %></td>
      <td><%= sample.cost_code %></td>
      <td><%= link_to "Show", sample %></td>
    </tr>
  <% end %>
</table>
```

Adding an Explicit Users Controller
===================================
To enable users to see a 'show' page, needed to add a users controller
(since we're using a 'user' model in devise (@app/controllers/users_controller.rb@):

```
class UsersController < ApplicationController
  def show
    @user = current_user
  end
end
```

and then construct an appropriate view listing the user's details and his
list of samples (@app/views/users/show.html.erb@):

```
<h2><%= "#{@user.firstname} #{@user.lastname}"%></h2>


<p>
  <strong>Group</strong>
  <%= "#{@user.group.group_desc}(#{@user.group.group_abbr})" %>
</p>
<p>
  <strong>EMail</strong>
  <%=@user.email %>
</p>
<p>
  <strong>Administrator?</strong>
  <%=@user.admin? ? 'yes' : 'no' %>
</p>

<h3><%="Samples" %></h3>

<table>
  <tr>
    <th>Code</th>
    <th>Params</th>
    <th>Status</th>
    <th>Update</th>
    <th>Priority</th>
    <th>Powd</th>
    <th>Chiral</th>
    <th>Cost Code</th>
    <th>Group</th>
  </tr>
  <% for sample in @user.samples %>
    <tr>
      <td><%= sample.code %></td>
      <td><%= sample.params %></td>
      <td><%= sample.flag.name %></td>
      <td><%= sample.updated_at %></td>
      <td><%= sample.priority %></td>
      <td><%= sample.powd %></td>
      <td><%= sample.chiral %></td>
      <td><%= sample.cost_code %></td>
      <td><%= link_to "Show", sample %></td>
    </tr>
  <% end %>
</table>

<%= link_to "Back", :back %>
```

Adding Some Admin Links
=======================
Administrators will need to add/edit pages, assets, research groups, hazards,
samples and status flags. To put links to the edit menus for these, we
edit the @app/views/layouts/application.html.erb@ file. To achieve what we
want, we edit the following container in the layout:

```
  <div id="user_nav">
    <% if user_signed_in? %>
      Signed in as <%= current_user.email %>. Not you?
      <%= link_to "Sign out", destroy_user_session_path, :method => :delete %>
      <br />
      <%= link_to 'My Samples', "/users/show/#{current_user.id}" %>
    <% else %>
      <%= link_to "Sign up", new_user_registration_path %> or
      <%= link_to "Sign in", new_user_session_path %>
    <% end %>
  </div>
```

Note that we have used the user show controller action and view.
Also add an extra layout for admins:

```
  <div id="admin_nav">
    <% if user_signed_in? and current_user.admin?%>
      Admin Tools:
      <%= link_to 'Hazards', hazards_path %> |
      <%= link_to 'User Groups', groups_path %> |
      <%= link_to 'Assets', assets_path %> |
      <%= link_to 'Pages', pages_path %> |
      <%= link_to 'Status Flags', flags_path %> |
      <%= link_to 'Samples', samples_path %>
    <% else %>
    <% end %>
  </div>
```

Restricting Users
=================
To stop users editing samples, we remove the Edit|Destroy|View All options
at the bottom of the show page if they are not an admin. Then we also
restrict their ability to do this completely (even if they know the
correct action URL) in the controller.
So, in @app/views/samples/show.html.erb@ we have:

```
<% if current_user.admin? %>
<p id="pdf_link">
  <%= link_to "Edit", edit_sample_path(@sample) %> |
  <%= link_to "Destroy", @sample, :confirm => 'Are you sure?', :method => :delete %> |
  <%= link_to "View All", samples_path %>
</p>
<% end %>
```
In the samples controller we add the following:

```
before_filter :admin_required :only => [:edit, :update, :destroy]
```

To prevent users viewing samples other than their own, we have this
in the samples controller:

```
  before_filter :must_be_creator_or_admin, :only => :show
```

with the filter code in the same file (since it's specific to the samples
controller):

```
private

  def must_be_creator_or_admin
    sample = Sample.find(params[:id])
    return true if (user_signed_in? and (current_user.admin? or current_user==sample.user))
    session[:return_to] = request.request_uri
    redirect_to root_url,
             :alert =>
             "You must be the sample owner or an administrator to view this sample!" and return false
  end
```

Notice, it's in a private block to be safe.

Sorting Columns
===============
It is important that the samples column be easily sortable. Used Ryan
Bates' method described in Railscasts 228. Unfortunately, this is not
the full answer because it only works on 'native' fields and not 
fields in related tables. For this I added some extra code using
SQL join instructions. This is not perfect because (amongst other things)
it is database-dependent, but for now it'll do. 

There is yet another problem with ordering samples by group - this is
because the group is not directly related to the sample. Rather, the
relationship is via the user, i.e. group --> user --> sample. It may
not be necessary to implement this (instead have a search box which
allows a listing of samples by group).
