RSpec Install
=============

After initial bundle install, need to do an explicit rspec install:

```
rails generate rspec:install
```

which creates the rspec dir.

Static Pages
============
Following Ryan Bates' method, used his nifty-generators (installed via
a ruby gem) to produce a Page
model:

```
rails generate nifty:scaffold Page name:string permalink:string content:text
```

Also installed the RedCloth gem in the Gemfile:

```
gem 'RedCloth'
```

which allows administrators to use the Textile markup language in their
static pages.

Used the carrierwave gem to facilitate file upload (the rmagick gem is
also useful when using carrierwave (we'll use it to auto-generate thumbnail
images when the full images are uploaded):

```
gem "rmagick"
gem "carrierwave"
```

Then created a carrierwave uploader called Document:

```
rails g uploader Document
```

A new model called Asset was created for explicitly uploading files:

```
rails g nifty:scaffold Asset document:string description:text
```

The Sample Model
================
The model requires barcode generation for which the ruby gem 'barby'
is used. Note that there is a problem with the other well-known barcode
generator based on gnu barcode. 'barby' is self-contained and doesn't need
anything else - it's pure ruby. 


The sample model contains the following parts:

code        This is autogenerated and takes the form AAA-AA-YY-1111 where
            the AAA and AA represent 3 letter codes for group and submitter
            respectively; the YY represents the year and the 1111 represents
            a number which is incremented for that group but reset to
            zero at the start of each calendar year. [string]

cif	    The proposed chemical formula in cif format. [string]

synth	    The synthetic route. This will be usually a chemdraw file or
            possibly an image file specifying the details of the synthesis.
            This will rely on a carrierwave uploader called Synth. [string]

coshh_name  Name of solvent (if any). [string]

coshh_desc  Brief description of sample (e.g. organic amide) [string]

coshh_info  List of any known hazards and procedures in case of contact. [text]

coshh_haz   Chemical hazard information. This will take the form
            of a list selected from checkboxes. The checkboxes will be
            generated from a separate chemical hazard table. [string]

params      Unit cell parameters or CSD/Newcastle code for possible 
            by-products or previously obtained, unpublished results. [string]

status      The status flag of the sample. This can be changed only by
            crystallography staff and initially will have the value
            'SUBMITTED'. Probably best if other values are selected from
            a drop-down list generated from a status flags table. It is
            hidden on the form (but should appear in the show/edit
            views). [string]

priority    User-defined priority number in case of multiple sample
            submissions. [integer]

powd        Is powder diffraction required yes/no. [boolean]

chiral      Is molecule chiral? yes/no. [boolean]

cost_code   This will be set by crystallography staff and allocated by
            finance staff. It is hidden on the form and will be blank
            by default but will be visible in show/edit views. [string]

barcode     An auto-generated barcode. This will use the ruby gem
            'barby'. [string]

Again, use nifty-generators to generate the sample model:

```
rails generate nifty:scaffold Sample code:string cif:string synth:string coshh_name:string coshh_desc:string coshh_info:text coshh_haz:string params:string status:string priority:integer powd:boolean chiral:boolean cost_code:string barcode:string
```

don't forget to migrate the database:

```
rake db:migrate
```

Create the carrierwave uploader for synthetic route file:

```
rails g uploader Synth
```

Edit the /app/models/sample.rb file and add the line:

```
mount_uploader :synth, SynthUploader
```

this links the synth field with the carrierwave fileuploader.

Then change the new sample form code. First need to make the form multipart
because we're uploading an external file along with the other data:

```
<%= form_for @sample, :html => {:multipart => true} do |f| %>
```

and also change the text box entry for the synth field to a file selection box:

```
<%= f.file_field :document %>
```

Chemical Hazard Codes
=====================
Each sample can be associated with zero or more chemical hazard codes
and vice-versa (i.e. a many-to-many relationship). 
Potentially, these codes could vary
and new ones could come in, so we create a small table for this.
The table has two fields: hazard_desc and hazard_abbr the second field
being the standard abbreviation of the first.
As before, use nifty generators for this:

```
rails generate nifty:scaffold Hazard hazard_desc:string hazard_abbr:string
```

This unfortunately means that we need to alter the sample table because
coshh_haz doesn't need to be there - rails3 will handle the many-to-many
association for us.
Do this with a migration:

```
rails generate migration remove_hazard_from_sample
```

Edit the migration to contain the following code:

```
class RemoveHazardFromSample < ActiveRecord::Migration
  def self.up
    remove_column :samples, :coshh_haz
  end

  def self.down
    add_column :samples, :coshh_haz, :string
  end
end
```

We must also set up a join table via another migration:

```
rails generate migration create_samples_hazards
```

with the following content:

```
class CreateSamplesHazards < ActiveRecord::Migration
  def self.up
    create_table :hazards_samples, :id => false do |t|
      t.references :sample, :null => false
      t.references :hazard, :null => false
    end
  end

  def self.down
    drop_table :hazards_samples
  end
end
```

Also, we need the following entries in the sample and hazard models
respectively (the files sample.rb and hazard.rb in app/models):

```
  has_and_belongs_to_many :hazards # sample.rb

  has_and_belongs_to_many :samples # hazard.rb
```

In the sample form, we can now add a set of checkboxes thus:

```
    <% for hazard in Hazard.find(:all) %>
    <div>
      <%= check_box_tag "sample[hazard_ids][]", hazard.id, @sample.hazards.include?(hazard) %>
      <%= hazard.hazard_desc %>
    </div>
    <% end %>
```

NOTE: for the above to work, you need to set :hazard_ids in the
attr_accessible flag of the sample model:

```
class Sample < ActiveRecord::Base
  attr_accessible :hazard_ids, :code, :cif, :synth, :coshh_name, :coshh_desc, :coshh_info, :coshh_haz, :params, :status, :priority, :powd, :chiral, :cost_code, :barcode
  has_and_belongs_to_many :hazards
```

if you don't add :hazard_ids as attr_accessible then you'll get the
following error in the server log:

```
WARNING: Can't mass-assign protected attributes: hazard_ids
```

Image Processing
================
When images of synthetic routes are uploaded, we want to generate a
thumbnail version (while still retaining the original) and display the
thumbnail on the show page but which is hyperlinked to the full image.
To do this, we need rmagick (which is installed via a gem as described
earlier). Then we edit the carrierwave uploader class file in:

```
app/uploaders/synth_uploader.rb
```

and edit/uncomment the thumbnail code already there to:

```
  version :thumb do
    process :resize_to_limit => [320, 240]
  end
```

this uses rmagick to resize the original image into a thumbnail version
for display. You will also need to uncomment the RMagick include statement
near the top of the app/uploaders/image_uploader.rb file.

```
  include CarrierWave::RMagick
```

Displaying the Barcode Graphic
==============================

Decided to use the Code39 standard. Need to first create a special
inline controller to actually display the barcode graphic (png). So, we
have this in the samples controller:

```
  def show_barcode

    require 'barby'
    require 'barby/barcode/code_39'
    require 'barby/outputter/png_outputter'
    #require 'barby/outputter/ascii_outputter'
    @sample = Sample.find(params[:id])

    barcode = Barby::Code39.new(@sample.barcode)

    # puts barcode.to_ascii #Implicitly uses the AsciiOutputter

    bcimage = barcode.to_png

    send_data bcimage, :type => 'image/png', :disposition => 'inline'

  end
```

We then have the following code in the samples 'show' view:

```
  <strong>Barcode:</strong>
  <%= @sample.barcode %><br />
  <%= image_tag url_for(:controller => "samples", :action => "show_barcode", :id => @sample.id) %>
```

We also need a route for this controller in config/routes.rb:

```
  match ':controller/:action/:id'
```

Create Table for Research Groups
================================
Here, we create a table for research groups (or any other groups) which
users will ultimately be linked with.

```
rails generate nifty:scaffold Group group_abbr:string group_desc:string
```

Now we want to limit the abbreviation string to 3 characters so we
create a new migration:

```
rails generate migration limit_group_abb
```

Then edit the migration file to contain:

```
class LimitGroupAbb < ActiveRecord::Migration
  def self.up
    change_column :groups, :group_abbr, :string, :limit => 3
  end

  def self.down
    change_column :groups, :group_abbr, :string, :limit => 255
  end
end
```

Add some validations for the group abbreviation:

```
  validates :group_abbr, :length => { :is => 3 }, :uniqueness => true
  validates :group_desc, :presence => true
  validates_format_of :group_abbr, :with => /[A-Z]{3}/
```

this restricts the abbreviation to a 3-capital letter unique string.

PDF Generation
==============

Decided to use PDFkit for this. First installed wkhtmltopdf by downloading
a static executable from the website and copying to /usr/local/bin and
/usr/bin (just to be sure). Next the Gemfile for PDFKit:

```
gem "pdfkit"
```

After the usual `bundle install`, added a line near the end of
the file `config/application.rb`:

```
    config.filter_parameters += [:password]
    config.middleware.use "PDFKit::Middleware"
  end
end
```

Then did a `rake middleware` to check that PDFKit was installed
correctly. Now, appending `.pdf` to a URL will render a PDF version
of that page. Unfortunately you can really only check this in production
mode because WEBrick is single-threaded (and still just displays the HTML).
You can test that the URL is accepted by the server however, even if it
doesn't display the HTML.

User Authentication with Devise
===============================
Followed Ryan Bates Railscast example. Added

```
gem 'devise', '1.4.9'
```

and then did a `bundle install` followed by:

```
rails generate devise:install
```

note colon rather than underscore in the above command.
Then needed to add the following to the development environment file
`config/environments/development.rb`:

```
config.action_mailer.default_url_options = { :host => 'localhost:3000' }
```

For production, need to add a similar line to the
`config/environments/production.rb` file, but with the name of the
actual machine replacing the `localhost:3000` bit. You must also set an
explicit @root_url@ in the `config/routes.rb` file such as:

```
root :to => "pages#home"
```

For this to work, also created a home controller action for the page model
in `app/controllers/pages_controller.rb` (initially using the 'about'
permalink but eventually this will be the 'home' permalink:

```
  def home
    @page = Page.find_by_permalink('about')
  end
```

and a view in `app/views/pages/home.html.erb` - this was almost identical to
the 'show' action view.

Also need to ensure you have flash messages in 
`app/views/layouts/application.html.erb`, e.g.:

```
<p class="notice"><%= notice %></p>
<p class="alert"><%= alert %></p>
```

This is achieved in the current application via some general flash code
in the view template (`app/views/layouts/application.html.erb`):

```
<% flash.each do |name, msg| %>
  <%= content_tag :div, msg, :id => "flash_#{name}" %>
<% end %>
```

After this, followed the user setup as explained by Ryan Bates (the devise 
docs also have clear instructions on how to do this).

Defining the User and Group Relationship
========================================
We need a one-to-many relationship between groups and users (a group has 
many users, but a user belongs to just one group. 
First, we must add a group_id integer field to the user model by creating
a migration as follows:

```
rails generate migration add_group_id_to_users group_id:integer
```

Also, we need the following entries in the user and group models
respectively (the files user.rb and group.rb in app/models):

```
  has_many :users # group.rb

  belongs_to :group # user.rb
```

The group_id field must be made accessible in the user model:

```
attr_accessible :email, :password, :password_confirmation, :remember_me, :group_id
```

We need to customise views in devise, so we first ask devise to generate files
for its default views (which are normally stored in the devise 'engine':

```
rails generate devise:views
```

This creates a lot of views which we can now edit to include groups.
The first files to change are the new user registration form and edit form:

```
app/views/devise/registrations/new.html.erb
app/views/devise/registrations/edit.html.erb
```

In the user form, we can now add a group select dropdown thus ( note that
the call to select is NOT preceded by the form object reference, i.e.
not f.select just select):

```
  <div><%= f.label "Group" %><br />
  <%= select(:user, :group_id, Group.all.collect {|g| [ g.group_desc, g.id ] },
    {:include_blank => 'None'}) %></div>
```

Modifying the User Model
========================
Needed to add a few more fields to the devise user model. First added a
boolean 'admin' field to denote whether a user is an administrator.
Did this via a migration as usual:

```
rails generate migration add_admin_to_user admin:boolean
```

Wanted to make the default for this @false@ so modified the migration
file by adding a `:default => false` directive to `add-column`:

```
class AddAdminToUser < ActiveRecord::Migration
  def self.up
    add_column :users, :admin, :boolean, :default => false
  end

  def self.down
    remove_column :users, :admin
  end
end
```

Then did a `rake db:migrate` and restarted the server. Then did a similar
thing to add `firstname` and `lastname` text fields. After this, edited
the user model file to make these new fields attribute accessible
in `app/models/user.rb`:

```
class User < ActiveRecord::Base
  # Include default devise modules. Others available are:
  # :token_authenticatable, :encryptable, :confirmable, :lockable, :timeoutable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable

  # Setup accessible (or protected) attributes for your model
  attr_accessible :email, :password, :password_confirmation, :remember_me, :group_id, :firstname, :lastname, :admin
end
```

Unfortunately, attempting to regenerate the devise views with:

```
rails generate devise:views
```

doesn't add entries for the new fields. Worse, it deletes the references
to the user group in the existing forms as created previously. Hence,
the new fields needed to be added to the forms:

```
  <div><%= f.label 'First Name' %><br />
  <%= f.text_field :firstname %></div>

  <div><%= f.label 'Last Name' %><br />
  <%= f.text_field :lastname %></div>
```

Note that the admin entry was not added, since it defaults to `false`.
It will (eventually) be available only for an administrator to edit.
The group reference was reinstated as before.

Defining the Sample and User Relationship
========================================
We need a one-to-many relationship between users and samples (a user has
many samples, but a sample belongs to just one user).
First, we must add a user_id integer field to the sample model by creating
a migration as follows:

```
rails generate migration add_user_id_to_samples user_id:integer
```

Also, we need the following entries in the sample and user models
respectively (the files sample.rb and user.rb in app/models):

```
  has_many :samples # user.rb

  belongs_to :user # sample.rb
```

The user_id field must be made accessible in the sample model:

```
  attr_accessible :hazard_ids, :code, :cif, :synth, :coshh_name, :coshh_desc, 
                  :coshh_info, :coshh_haz, :params, :status, :priority, 
                  :powd, :chiral, :cost_code, :barcode, :user_id
```

When creating a sample, the user is associated with it via this simple
piece of code in the create function of the sample controller (note the
current_user function supplied by devise):

```
  def create
    # @sample = Sample.new(params[:sample])
    @sample = current_user.samples.build params[:sample]
    if @sample.save
      redirect_to @sample, :notice => "Successfully created sample."
    else
      render :action => 'new'
    end
  end
```

Basic Refinement of Views
=========================
Next, refine some of the views. For example, the samples index really
needs to show only a few basic things - so we strip off things such
as the reaction pathway image and add a column to show the user who
submitted the sample and his research group.
It is easy to add a link to a user and group in the main samples index:

```
<td><%= "#{sample.user.firstname} #{sample.user.lastname}"  %></td>
<td><%= "#{sample.user.group.group_desc}"  %></td>
```

Auto-Generation of Sample Code
==============================
Neede to auto-generate the sample code string which takes the following format:

```
AAA-AA-YY-1111
```

the AAA represent 3 letter codes for supervisor and submitter
respectively; the YY represents the year and the 1111 represents
a number which is incremented for that supervisor but reset to
zero at the start of each calendar year. The AAA part is taken from the
three letter group abbreviation and the AA part is taken from the
user initials. the year is trivial and a bit of code is needed to generate
the 4-digit trailing number. The code to do this goes in the controller
rather than the model, since it relies on pulling information from the
user and group tables. Here is the code in the samples controller file:

```
  def make_sample_code
    x = Time.now
    grp = current_user.group.group_abbr
    usr = current_user.firstname.first.upcase +
           current_user.lastname.first.upcase
    yr  = x.strftime('%g')
    num = create_sample_num
    "#{grp}-#{usr}-#{yr}-#{num}"
  end

  def create_sample_num
    x = Time.now
    yr = x.strftime('%g')
    grp = current_user.group.group_abbr
    samps = Sample.where('code LIKE ?', "#{grp}-%-#{yr}-%").all
    if (samps.length > 0)
      str = samps.last.code
      last_num = /\d\d\d\d$/.match(str)[0].to_i
      new_num = last_num + 1
      # now an amazing idiom to convert to 4 digit string!
      return "%04d" % new_num
    else
      return "%04d" % 1
    end
  end
```

These functions are then used later in the 'new' function:

```
  def new
    @sample = Sample.new
    @sample.code = make_sample_code
  end
```

View and Controller Permissions: Making a Start
===============================================

First, we change the permissions on the semi-static pages by making the
Edit/Destroy etc links disappear for all users (whether signed-in or not)
except when a user is signed in and is an administrator. This needs only
to be done for the `home.html.erb` and `show.html.erb` views.
Here's the code we use:

```
<% if user_signed_in? %>

<% if current_user.admin? %>
<p>
  <%= link_to "Edit", edit_page_path(@page) %> |
  <%= link_to "Destroy", @page, :confirm => 'Are you sure?', :method => :delete %> |
  <%= link_to "View All", pages_path %> |
  <%= link_to "Input Help", "http://en.wikipedia.org/wiki/Textile_%28markup_language%29", :target => "_blank" %>
</p>

<% else %>
<p>
</p>
<% end %>

<% end %>
```

Of course, this just prevents the links being seen --- we still need to
protect the controllers. Do this by defining a before filter
called `admin_required` in the `application_controller.rb` file:

```
  def admin_required
    return true if user_signed_in? and current_user.admin?
    session[:return_to] = request.request_uri
    redirect_to root_url,
             :alert => 
             "You must be an administrator to do this!" and return false
  end
```

We then make use of this in the pages controller file:

```
  before_filter :admin_required, :only => [ :new, :create, :index, :edit,
                                            :update, :destroy ]
```

In this way, we protect the semi-static pages from being edited
by an unauthorized user.

Setting up a Status Flag Table
==============================
It was decided to set up a special table to hold status flag strings. The
table is very simple, consisting of a string field and a text field
to hold the status flag and some brief explanatory text.
As usual, RB's nifty generators were used:

```
rails generate nifty:scaffold Flag name:string description:text
```

We need a one-to-many relationship between status flags and samples 
(a flag can be associated with many samples, but a sample has just one 
status flag at any one time.
First, we must add a flag_id integer field to the sample model by creating
a migration as follows:

```
rails generate migration add_flag_id_to_samples flag_id:integer
```

Also, we need the following entries in the sample and flag models
respectively (the files `sample.rb` and `flag.rb` in `app/models`):

```
  has_many :samples # flag.rb

  belongs_to :flag # sample.rb
```
We now remove `:status` from the `attr_accessible` flag of the sample model
as well as its validation line from `app/models/sample.rb`.
Of course, we must now also remove the status field from the sample model.
Do this with a migration:

```
rails generate migration remove_status_from_sample
```

Edit the migration to contain the following code:

```
class RemoveHazardFromSample < ActiveRecord::Migration
  def self.up
    remove_column :samples, :status
  end

  def self.down
    add_column :samples, :status, :string
  end
end
```

Forcing a Default Status Flag for a New Sample
==============================================
This seemed a sensible thing to do, so a migration was applied. The
migration file had the following content:

```
class AddDefaultValueForStatusToSample < ActiveRecord::Migration
  def self.up
    change_column :samples, :flag_id, :integer, :default => 1, :null => false
  end

  def self.down
    change_column :samples, :flag_id, :integer
  end
end
```

Adding User sample Listing on Edit User Page
===========================================
This is achieved by editing the `app/views/devise/registrations/edit.html.erb`
page with the following code:

```
<h3><%="My Samples" %></h3>

<table>
  <tr>
    <th>Code</th>
    <th>Params</th>
    <th>Status</th>
    <th>Update</th>
    <th>Priority</th>
    <th>Powd</th>
    <th>Chiral</th>
    <th>Cost Code</th>
    <th>Group</th>
  </tr>
  <% for sample in @user.samples %>
    <tr>
      <td><%= sample.code %></td>
      <td><%= sample.params %></td>
      <td><%= sample.flag.name %></td>
      <td><%= sample.updated_at %></td>
      <td><%= sample.priority %></td>
      <td><%= sample.powd %></td>
      <td><%= sample.chiral %></td>
      <td><%= sample.cost_code %></td>
      <td><%= link_to "Show", sample %></td>
    </tr>
  <% end %>
</table>
```

Adding an Explicit Users Controller
===================================
To enable users to see a 'show' page, needed to add a users controller
(since we're using a 'user' model in devise (`app/controllers/users_controller.rb`):

```
class UsersController < ApplicationController
  def show
    @user = current_user
  end
end
```

and then construct an appropriate view listing the user's details and his
list of samples (`app/views/users/show.html.erb`):

```
<h2><%= "#{@user.firstname} #{@user.lastname}"%></h2>


<p>
  <strong>Group</strong>
  <%= "#{@user.group.group_desc}(#{@user.group.group_abbr})" %>
</p>
<p>
  <strong>EMail</strong>
  <%=@user.email %>
</p>
<p>
  <strong>Administrator?</strong>
  <%=@user.admin? ? 'yes' : 'no' %>
</p>

<h3><%="Samples" %></h3>

<table>
  <tr>
    <th>Code</th>
    <th>Params</th>
    <th>Status</th>
    <th>Update</th>
    <th>Priority</th>
    <th>Powd</th>
    <th>Chiral</th>
    <th>Cost Code</th>
    <th>Group</th>
  </tr>
  <% for sample in @user.samples %>
    <tr>
      <td><%= sample.code %></td>
      <td><%= sample.params %></td>
      <td><%= sample.flag.name %></td>
      <td><%= sample.updated_at %></td>
      <td><%= sample.priority %></td>
      <td><%= sample.powd %></td>
      <td><%= sample.chiral %></td>
      <td><%= sample.cost_code %></td>
      <td><%= link_to "Show", sample %></td>
    </tr>
  <% end %>
</table>

<%= link_to "Back", :back %>
```

Adding Some Admin Links
=======================
Administrators will need to add/edit pages, assets, research groups, hazards,
samples and status flags. To put links to the edit menus for these, we
edit the `app/views/layouts/application.html.erb` file. To achieve what we
want, we edit the following container in the layout:

```
  <div id="user_nav">
    <% if user_signed_in? %>
      Signed in as <%= current_user.email %>. Not you?
      <%= link_to "Sign out", destroy_user_session_path, :method => :delete %>
      <br />
      <%= link_to 'My Samples', "/users/show/#{current_user.id}" %>
    <% else %>
      <%= link_to "Sign up", new_user_registration_path %> or
      <%= link_to "Sign in", new_user_session_path %>
    <% end %>
  </div>
```

Note that we have used the user show controller action and view.
Also add an extra layout for admins:

```
  <div id="admin_nav">
    <% if user_signed_in? and current_user.admin?%>
      Admin Tools:
      <%= link_to 'Hazards', hazards_path %> |
      <%= link_to 'User Groups', groups_path %> |
      <%= link_to 'Assets', assets_path %> |
      <%= link_to 'Pages', pages_path %> |
      <%= link_to 'Status Flags', flags_path %> |
      <%= link_to 'Samples', samples_path %>
    <% else %>
    <% end %>
  </div>
```

Restricting Users
=================
To stop users editing samples, we remove the Edit|Destroy|View All options
at the bottom of the show page if they are not an admin. Then we also
restrict their ability to do this completely (even if they know the
correct action URL) in the controller.
So, in `app/views/samples/show.html.erb` we have:

```
<% if current_user.admin? %>
<p id="pdf_link">
  <%= link_to "Edit", edit_sample_path(@sample) %> |
  <%= link_to "Destroy", @sample, :confirm => 'Are you sure?', :method => :delete %> |
  <%= link_to "View All", samples_path %>
</p>
<% end %>
```
In the samples controller we add the following:

```
before_filter :admin_required :only => [:edit, :update, :destroy]
```

To prevent users viewing samples other than their own, we have this
in the samples controller:

```
  before_filter :must_be_creator_or_admin, :only => :show
```

with the filter code in the same file (since it's specific to the samples
controller):

```
private

  def must_be_creator_or_admin
    sample = Sample.find(params[:id])
    return true if (user_signed_in? and (current_user.admin? or current_user==sample.user))
    session[:return_to] = request.request_uri
    redirect_to root_url,
             :alert =>
             "You must be the sample owner or an administrator to view this sample!" and return false
  end
```

Notice, it's in a private block to be safe.

Sorting Columns
===============
It is important that the samples column be easily sortable. Used Ryan
Bates' method described in Railscasts 228. Unfortunately, this is not
the full answer because it only works on 'native' fields and not 
fields in related tables. For this I added some extra code using
SQL instructions.

First in the samples controller I added two private helper methods:

```
  def sort_column
    cols = Sample.column_names + Flag.column_names + Group.column_names + User.column_names
    cols.include?(params[:sort]) ? params[:sort] : "code"
  end

  def sort_direction
    %w[asc desc].include?(params[:direction]) ? params[:direction] : "asc"
  end
```

To make these accessible within views, they must explicity be labelled
as helper methods at the beginning of the controller code:

```
class SamplesController < ApplicationController
  helper_method :sort_column, :sort_direction
```

The first helper defines a set of columns over which we want to sort.
In this case, the list includes columns from the Flag, Group and User
tables as well as the Sample table. In the URL, one column will be
tagged as a sort column - if the column in the URL is not one of those
in the cols list, then the sort column will default to 'code'.

The second helper sets either a descending or ascending order - this
will alternate with successive clicks on the link. 
The sort column is selected by clicking on the header
which then send a URL of the form:

```
http://server/samples?direction=<asc|desc>&sort=<col>
```

The index function in the samples controller is re-written as:

```
  def index
     @samples=Sample.all( :joins => [:flag, {:user => :group}],
                          :order => "#{sort_column} #{sort_direction}")
  end
```

Note that the SQL ordering is set using the helpers and we have done an
inner join on the samples data so we can access the external tables
and their columns.

The index view in the file `app/views/samples/index.html.erb` now has
these entries in the header region:

```
<table class="pretty">
  <tr>
    <th><%= sortable "code", "Code" %></th>
<!--    <th><%= sortable "params", "Parameters" %></th> -->
    <th><%= sortable "name", "Status" %></th>
    <th><%= sortable "created_at", "Submitted" %></th>
    <th><%= sortable "updated_at", "Updated" %></th>
    <th><%= sortable "priority", "Priority" %></th>
<!--    <th><%= sortable "powd", "Powd?" %></th> -->
<!--    <th><%= sortable "chiral", "Chiral?" %></th> -->
<!--    <th><%= sortable "cost_code", "Cost Code" %></th> -->
    <th><%= sortable "lastname", "User" %></th>
    <th><%= sortable "group_abbr", "Group" %></th>
  </tr>
```

Here we use a helper called `sortable` to set up the appropriate links.
This helper is defined in `app/helpers/application_helper.rb` since
it is fairly generic:

```
module ApplicationHelper

  def sortable(column, title = nil)
    title ||= column.titleize
    css_class = column == sort_column ? "current #{sort_direction}" : nil
    direction = column == sort_column && sort_direction == "asc" ? "desc" : "asc"
    link_to title, {:sort => column, :direction => direction}, {:class => css_class}
  end

  def neat_time(date)
     date.strftime("%d/%m/%Y") + date.strftime("(%I:%M%P)")
  end

end
```

Note also the function `neat_time` which is used for displaying 'neat'
timestamps in tables.
Finally, added some CSS code to display an up/down arrow to indicate
both the current ordered column and its sorting direction. This is
in the file `public/stylesheets/application.css`:

```
table.pretty {
  border-collapse: collapse;
}

.pretty td, .pretty th {
  padding: 4px 10px;
}

.pretty th .current {
  padding-right: 12px;
  background-repeat: no-repeat;
  background-position: right center;
}
.pretty th .asc {
  background-image: url(/images/up_arrow.gif);
}

.pretty th .desc {
  background-image: url(/images/down_arrow.gif);
}
```

We need to do something similar in the 'My Samples' page for each user.
There are some subtle differences however. First, here is the controller
code for the user model:

```
class UsersController < ApplicationController

helper_method :sort_column, :sort_direction

  def show
    @user = current_user
    s = @user.samples
    @samples=s.all( :joins => :flag,
                    :order => "#{sort_column} #{sort_direction}")

  end

private

  def sort_column
    cols = Sample.column_names + Flag.column_names
    cols.include?(params[:sort]) ? params[:sort] : "code"
  end

  def sort_direction
    %w[asc desc].include?(params[:direction]) ? params[:direction] : "asc"
  end

end
```

We have introduced the same helper functions as before but `sort_column`
is slightly different because we only need to sort on fields from the
sample and flag tables. We must also define a samples list which is
done with a similar join as before. Now the samples section on the user
show page looks like this:

```
<h3><%="Samples" %></h3>
<% if @user.samples.count > 0 %>
<table class="pretty">
  <tr>
    <th><%= sortable "code", "Code" %></th>
    <th><%= sortable "params", "Params" %></th>
    <th><%= sortable "name", "Status" %></th>
    <th><%= sortable "created_at", "Submitted" %></th>
    <th><%= sortable "updated_at", "Updated" %></th>
    <th><%= sortable "priority", "Priority" %></th>
    <th><%= sortable "powd", "Powd?" %></th>
    <th><%= sortable "chiral", "Chiral?" %></th>
    <th><%= sortable "cost_code", "Cost Code" %></th>
  </tr>
  <% for sample in @samples %>
    <tr>
      <td><%= sample.code %></td>
      <td><%= sample.params %></td>
      <td><%= sample.flag.name %></td>
      <td><%= neat_time(sample.created_at) %></td>
      <td><%= neat_time(sample.updated_at) %></td>
      <td><%= sample.priority %></td>
      <td><%= sample.powd %></td>
      <td><%= sample.chiral %></td>
      <td><%= sample.cost_code %></td>
      <td><%= link_to "Show", sample %></td>
    </tr>
  <% end %>
</table>
<% else %>
<p>
You have no samples!
</p>
```

Amazingly, it all seems to work!

Additions to sample Model
=========================
Added a text string as a user reference. restrict this to be an alphanumeric
string with no spaces (validation). The migration file looks like this:

```
class AddUserrefTo_sample < ActiveRecord::Migration
  def self.up
    add_column :samples, :userref, :string, :default => nil
  end

  def self.down
    remove_column :samples, :userref
  end
end
```

Note the default is nil, but the validation process in the model
(`app/models/sample.rb`) will require this to be changed:

```
  validates :userref,    :format => {
    :with     => %r{^[A-Z,a-z,0-9]+$},
    :message  => 'must be alphanumeric sequence of characters without spaces.'
  }
```

Finally, need to add the userref field as attribute_accessible in the
user model.

Decided to remove the default value for userref so change this
with a migration:

```
class ChangeUserrefDefaultIn_sample < ActiveRecord::Migration
  def self.up
    change_column :samples, :userref, :string
  end

  def self.down
    change_column :samples, :userref, :string, :default => nil
  end
end
```

CRUD Interface to User Model
============================
Devise doesn't create a CRUD interface by default. We create one by following the devise docs and
the excellent summary by "Brandon Martin":http://zyphmartin.com/blog/manage-users-with-devise-and-cancan.
We will also make use of Ryan Bates' `cancan` gem for some authorization here. We add cancan to the
Gemfile and do a bundle install. After installing cancan, need to create an `Ability` class. Do this
by typing:

```
rails g cancan:ability
```

which creates a file `app/models/ability.rb`. This file is used by cancan to define abilities. At present,
we follow Brandon Martin with the following setup:

```
class Ability
  include CanCan::Ability

  def initialize(user)
   if user.admin?
     can :manage, :all
   else
     can :read, :all
   end
end
```

We will probably add to this later. Cancan assumes that there is a `current_user` method - no problem
since we're using devise.

For the CRUD interface first thing to do is set up the correct routes. 
Here's what we need in the `config/routes.rb` file:

```
  devise_for :users

  devise_scope :user do
    get '/login' => 'devise/sessions#new'
    get '/logout' => 'devise/sessions#destroy'
  end

  resources :user, :controller => "user"
```

Previously we had just `resources :users`, but now this is changed to a `:user` resource (singular) and a 
`devise_scope` directive.

Next, we need to create the `user` controller in `app/controllers/user_controller.rb`. We list it here in full:

```
class UserController < ApplicationController

  helper_method :sort_column, :sort_direction

  before_filter :authenticate_user!
  before_filter :must_be_user_or_admin, :only => [:show, :edit, :update]
  before_filter :admin_required, :only => [:index, :destroy]

  load_and_authorize_resource

  def index
    @users = User.all
  end

  def new
    @user = User.new
  end

  def create
    @user = User.new(params[:user])
    if @user.save
      flash[:notice] = "Successfully created User."
      redirect_to root_path
    else
      render :action => 'new'
    end
  end

  def show
    @user = User.find(params[:id])
    s = @user.samples
    @samples=s.all( :joins => :flag,
    :order => "#{sort_column} #{sort_direction}")
  end

  def edit
    @user = User.find(params[:id])
  end

  def update
    @user = User.find(params[:id])
    params[:user].delete(:password) if params[:user][:password].blank?
    params[:user].delete(:password_confirmation) if params[:user][:password].blank? and params[:user][:password_confirmation].blank?
    if @user.update_attributes(params[:user])
      flash[:notice] = "Successfully updated User."
      redirect_to root_path
    else
      render :action => 'edit'
    end
  end

  def destroy
    @user = User.find(params[:id])
    if @user.destroy
      flash[:notice] = "Successfully deleted User."
      redirect_to root_path
    end
  end

private

  def sort_column
    cols = Sample.column_names + Flag.column_names
    cols.include?(params[:sort]) ? params[:sort] : "code"
  end

  def sort_direction
    %w[asc desc].include?(params[:direction]) ? params[:direction] : "asc"
  end

  def must_be_user_or_admin
    user = User.find(params[:id])
    return true if (user_signed_in? and (current_user.admin? or current_user==user))
    session[:return_to] = request.request_uri
    redirect_to root_url,
             :alert =>
             "You must be the relevant user or an administrator to view or edit this user's details!" and return false
  end

end
```

Now, in `app/views/user` we add the following view templates:

```
edit.html.erb  _form.html.erb  index.html.erb  new.html.erb  show.html.erb
```

Here is the content of the various files.

`_form.html.erb`
================
```
<%= f.error_messages %>

<p><%= f.label "First Name" %><br />
<%= f.text_field :firstname %></p>

<p><%= f.label "last Name" %><br />
<%= f.text_field :lastname %></p>

<p><%= f.label :email %><br />
<%= f.text_field :email %></p>

  <div><%= f.label "Group" %><br />
  <%= select(:user, :group_id, Group.all.collect {|g| [ g.group_desc, g.id ] },
    {:include_blank => 'None'}) %></div>

<p>
<%= label_tag(:admin, "Administrator?") %>
<%= f.check_box(:admin) %>
</p>

<p><%= f.label :password %><br />
<%= f.password_field :password %></p>

<p><%= f.label :password_confirmation %><br />
<%= f.password_field :password_confirmation %></p>

<p><%= f.submit "Submit" %></p>
```

`edit.html.erb`
===============
```
% title "Edit User" %>

<%= form_for @user, :url => user_path do |f| %>
  <%= render :partial => 'form', :locals => { :f => f } %>
<% end %>
```

`index.html.erb`
================
```
<% title "Users" %>

<table>
  <tr>
    <th>First Name</th>
    <th>Last name</th>
    <th>Group</th>
  </tr>
  <% for user in @users %>
    <tr>
      <td><%= user.firstname %></td>
      <td><%= user.lastname %></td>
      <td><%= user.group.group_desc %></td>
      <td><%= link_to "Show", user %></td>
      <td><%= link_to "Edit", edit_user_path(user) %></td>
      <td><%= link_to "Destroy", user, :confirm => 'Are you sure?', :method => :delete %></td>
    </tr>
  <% end %>
</table>

<p><%= link_to "New User", new_user_path %></p>
```

`new.html.erb`
==============
```
<% title "New User" %>

<%= form_for @user, :url => user_index_path do |f| %>
  <%= render :partial => 'form', :locals => { :f => f } %>
<% end %>
```

`show.html.erb`
===============
```
<h2><%= "#{@user.firstname} #{@user.lastname}"%></h2>


<p>
  <strong>Group</strong>
  <%= "#{@user.group.group_desc} (#{@user.group.group_abbr})" %>
</p>
<p>
  <strong>EMail</strong>
  <%=@user.email %>
</p>
<p>
  <strong>Administrator?</strong>
  <%=@user.admin? ? 'yes' : 'no' %>
</p>

<h3><%="Samples" %></h3>
<% if @user.samples.count > 0 %>
<table class="pretty">
  <tr>
    <th><%= sortable "code", "Code" %></th>
    <th><%= sortable "userref", "Ref" %></th>
    <th><%= sortable "params", "Params" %></th>
    <th><%= sortable "name", "Status" %></th>
    <th><%= sortable "created_at", "Submitted" %></th>
    <th><%= sortable "updated_at", "Updated" %></th>
    <th><%= sortable "priority", "Priority" %></th>
    <th><%= sortable "powd", "Powd?" %></th>
    <th><%= sortable "chiral", "Chiral?" %></th>
    <th><%= sortable "cost_code", "Cost Code" %></th>
  </tr>
 <% for sample in @samples %>
    <tr>
      <td><%= sample.code %></td>
      <td><%= sample.userref %></td>
      <td><%= sample.params %></td>
      <td><%= sample.flag.name %></td>
      <td><%= neat_time(sample.created_at) %></td>
      <td><%= neat_time(sample.updated_at) %></td>
      <td><%= sample.priority %></td>
      <td><%= sample.powd %></td>
      <td><%= sample.chiral %></td>
      <td><%= sample.cost_code %></td>
      <td><%= link_to "Show", sample %></td>
    </tr>
  <% end %>
</table>
<% else %>
<p>
You have no samples!
</p>
<% end %>

<%= link_to "Back", :back %>
```

Note that the show form also shows the user's samples and that all of the pages, where appropriate, use the
column sorting tricks first used earlier.

Additions to Sample Model
========================
Added a field `zipdata` via a migration called
`add_zipdata_to_sample`. This is for a data file upload supplied by
an administrator after a sample has been analyzed. Used carrierwave
as previously with an uploader called `Zipdata` generated via:

```
rails g uploader Zipdata
```

and an extra entry to the `app/models/sample.rb` file:

```
mount_uploader :zipdata, ZipdataUploader
```

Changed the sample show/edit views and sample form accordingly.
As with the status flag, only an administrator can change this field.

Also added a field `sampleimage` via a migration called
`add_sampleimage_to_sample`. This is an image of the sample which is
uploaded after analysis by crystallography staff. 
Used carrierwave as previously with an uploader called `Sampleimage` 
generated via:

```
rails g uploader Sampleimage
```

and an extra entry to the `app/models/sample.rb` file:

```
mount_uploader :sampleimage, SampleimageUploader
```

We also create a thumbnail image (as with the synthetic route image file)
by making appropriate edits (described earlier in the synthetic
route image case) to the file:

```
app/uploaders/sampleimage_uploader.rb
```

Note that as ever, we must add any new fields that are editable to the
attribute accessible list in the file `app/models/sample.rb`:

```
class Sample < ActiveRecord::Base
  attr_accessible :hazard_ids, :code, :cif, :synth, :coshh_name, :coshh_desc, 
                  :coshh_info, :coshh_haz, :params, :priority, :powd, :chiral, 
                  :cost_code, :barcode, :user_id, :flag_id, :userref, 
                  :zipdata, :sampleimage
```



As with the zip data file
the sample show/edit views and sample form are changed accordingly.
Only an administrator can change this field.

Adding a DOI Reference Field
============================
This field allows the administrator to add a link to a reference in which
the structure has been published. This will take the form (usually) of
a DOI link. We start with a migration

```
rails generate migration add_reference_to_sample
```

Adding a Help Popups Table
==========================
This is a table of help strings. The idea is that administrators can
add arbitrary help strings which can be made to popup in some forms.
Initially, only the sample submission form will use these, but in
principle, any form can do so.
As usual, RB's nifty generators were used:

```
rails generate nifty:scaffold Popup name:string description:text
```

In the file `app/helpers/samples_helper.rb` we define a function to
display the popup description text:

```
  def popup_info( ref_str )
    if (p = Popup.find_by_name( ref_str ))
      p.description
    end
  end
```

and in the sample form, we have entries such as:

```
  <p>
    <%= f.label 'Your Ref' %><br />
    <%= f.text_field :userref, :title => popup_info('sample_yourref')%>
  </p>
```

This will display a popup box showing the popup description text, in this
case corresponding to the `sample_yourref` popup name. It is
recommended when using popups that a consistent naming convention is
adopted. In this case we have used `<model>_<field>` as the naming
convention for the popup.

Adding Group Leader Status
==========================
We add an extra boolean field to the User model to indicate that the
user is a 'group leader'. At present, all this does is allow such users
to look at ALL the samples submitted by a group, not just their own.
Additionally, they will receive e-mails when any group sample is
submitted or updated. This was achieved by adding an appropriate
migration to add a new field `leader` to the user model.

A new controller action called `groupindex` was added to the sample 
controller. This lists all the samples of the group to which the user
belongs. However, only group leaders can execute this action:

```
  def groupindex
    @samples=Sample.where("code LIKE '#{current_user.group.group_abbr}%'").joins(:flag, {:user => :group}).order("#{sort_column} #{sort_direction}")
#                          :joins => [:flag, {:user => :group}],
  end
```

Note that we have relied on comparing the sample code string to the
group abbreviation string belonging to the group of the current user.
This is OK because such abbreviation strings are unique.
A before filter called `must_be_leader_or_admin` was also added to
restrict access to this new controller:

```
  def must_be_leader_or_admin
    return true if (user_signed_in? and (current_user.admin? or current_user.leader?))
    session[:return_to] = request.request_uri
    redirect_to root_url,
             :alert =>
             "You must be a group leader or an administrator to view all group samples!" and return false
  end
```

At the top of the controller, we add the line:

```
  before_filter :must_be_leader_or_admin, :only => :groupindex
```

In the file `app/views/layouts/application.html.erb` we add some code to
display a link to the group samples index if the user is a group leader:

```
     <% if user_signed_in? and (current_user.admin? or current_user.leader?) %>
        <%= link_to 'My Group Samples', :controller => "samples",
                                        :action => "groupindex",
                                        :id => current_user.id %> |
      <% end %>
```

Note that strictly the `:id` parameter is not necessary, but is passed
to satisfy the routing requirements.

Redoing PDF output
==================
Decided to switch to Prawn. After installing Prawn via an entry in the 
Gemfile, the following was added to the file
`config/initializers/mime_types.rb `:

```
Mime::Type.register "application/pdf", :pdf
```

Only the sample 'show' action will initially have PDF support.
To enable the support, we change the 'show' code to:
```
  def show
    @hazards = Hazard.find(:all)
    @sample = Sample.find(params[:id])
    respond_to do |format|
      format.html
      format.pdf do
        pdf = SamplePdf.new(@sample)
        send_data pdf.render, filename: "sample_#{@sample.code}",
                              type: "application/pdf"

      end
    end
  end
```

The code has been modified with a `respond_to` directive which includes
pdf. At the end of the pdf response, the pdf output is rendered via
`send_data` to a file called `sample_<sample code>.pdf`.
To keep the controller code clean, most of the work is handled by a new
class called `SamplePdf` defined in the file `app/pdfs/sample_pdf.rb`.
The `app/pdfs` directory was created first. the contents of this file
are as follows:

```
class SamplePdf < Prawn::Document
  
  def initialize(sample)
    super(page_size: "A4")
    @sample = sample
    @hazards = Hazard.find(:all)
    header
    structure
    sample_code
    coshh
    scissor_line
    show_barcode
    coshh_summary
      
  end

  def header
    nbsp = Prawn::Text::NBSP
      text "Newcastle Crystallography Service", font: "Helvetica", size: 30, style: :bold, align: :center
      text "Bedson Building#{nbsp}#{nbsp} " + 
           "<font name='ZapfDingbats' size='12'>F#{nbsp}#{nbsp}#{nbsp}</font>" + 
           "#{nbsp}#{nbsp}Newcastle University#{nbsp}#{nbsp}" + 
           "<font name='ZapfDingbats' size='12'>#{nbsp}#{nbsp}F#{nbsp}#{nbsp}</font>" + 
           "#{nbsp}#{nbsp}NE1 7RU", size: 16, 
             align: :center, :inline_format => true

    move_down 10
    stroke do
      horizontal_rule
    end
  end

  def sample_code
    text_box "Sample Code: #{@sample.code}", size: 16, style: :bold, align: :left, :at => [0,bounds.top-84]
    move_up 16
    text_box "Your Ref: #{@sample.userref}", size: 16, style: :bold, align: :right, :at => [250,bounds.top-84]
    intro_str = "Please check the details on this receipt. " +
                "Changes can be made only by Crystallography staff." +
                "Please use the tear-off slip at the bottom of the page and " +
                "attach it to your sample. You will be automatically " +
                "informed via e-mail of any changes to your sample status."
    text_box intro_str, size: 10, size: 10, :at => [0,bounds.top-104]
  end

  def show_barcode

    require 'tempfile'
    require 'barby'
    require 'barby/barcode/code_39'
    require 'barby/outputter/png_outputter'
    #require 'barby/outputter/ascii_outputter'

    barcode = Barby::Code39.new(@sample.barcode)

    # puts barcode.to_ascii #Implicitly uses the AsciiOutputter

    pagewidth = bounds.right - bounds.left
    bounding_box([0,108], :width => pagewidth) do

      font("Courier" ) do
        draw_text "#{@sample.code}", size: 14, style: :bold, :at => [32,cursor+3]
      end

      temp_file = Tempfile.new(['bc', '.png'])

      temp_file.write barcode.to_png(:margin => 0)
      temp_file.close

      image temp_file.path

      temp_file.close(true)

      bc_str = @sample.barcode.gsub(/(.{1})(?=.)/, '\1 \2')
    

      font("Courier" ) do
        draw_text "#{bc_str}", size: 12, style: :bold, :at => [7,cursor-10]
      end
    end

  end

  def scissor_line
    vmiddle=(bounds.top + bounds.bottom)*0.5
    hmiddle=(bounds.left + bounds.right)*0.5
    pagewidth = bounds.right - bounds.left
    bounding_box([0,154], :width => pagewidth) do
      dash(5, :space => 5, :phase => 3)
      stroke do
        pad(20) {
          font("ZapfDingbats", :size => 28) do
            draw_text "$", :at => [hmiddle,cursor]
          end
          move_up 10
          horizontal_rule
        }
      end
      undash
    end
  end

  def structure

    pagewidth = bounds.right - bounds.left
    boxwidth = pagewidth*0.5 - 5
    boxheight = 0.75*boxwidth
  # 
  # This next bit gives the absolute path name of the structure image
  #
    strucfile = Rails.root.to_s + '/public' + @sample.synth_url.to_s
  #
    text_box "Proposed Structure and Synthetic Route", size: 12, style: :bold, align: :left, :at => [0,bounds.top-168]
    text_box "Sample Details and Requirements", size: 12, style: :bold, align: :left, :at => [boxwidth+10,bounds.top-168]

    bounding_box([0,bounds.top-182], :width => boxwidth, :height => boxheight) do
      image strucfile, :position => :center, :height => boxheight*0.9, :width => boxwidth*0.9
    stroke_bounds
    end
    bounding_box([boxwidth+10 ,bounds.top-182], :width => boxwidth, :height => boxheight*0.25-5) do
      bounding_box([5 ,bounds.top-5], :width => boxwidth-10, :height => boxheight-10) do
        text "<b>Powder Diffraction Required?</b> #{@sample.powd ? 'Yes' : 'No'}", :size => 10, :inline_format => true
        text "<b>Chiral Structure?</b> #{@sample.chiral ? 'Yes' : 'No'}", :size => 10, :inline_format => true
        text "<b>Your Priority Number:</b> #{@sample.priority}", :size => 10, :inline_format => true
      end
      stroke_bounds
    end
    text_box "User Details", size: 12, style: :bold, align: :left, :at => [boxwidth+10,bounds.top-248]
    bounding_box([boxwidth+10 ,bounds.top-262], :width => boxwidth, :height => boxheight*0.7 -22) do
      bounding_box([5 ,bounds.top-5], :width => boxwidth-10, :height => boxheight-10) do
        text "<b>Submission Date:</b> #{@sample.created_at}", :size => 10, :inline_format => true
        text "<b>Submitted By:</b> #{@sample.user.firstname} #{@sample.user.lastname}", :size => 10, :inline_format => true
        text "<b>Research Group:</b>  #{@sample.user.group.group_desc}", :size => 10, :inline_format => true
        text "<b>Contact E-Mail:</b>  #{@sample.user.email}", :size => 10, :inline_format => true
        text "<b>Cost Centre Code:</b> #{@sample.cost_code}", :size => 10, :inline_format => true
        text "<b>Assigned Bar Code:</b> #{@sample.barcode}", :size => 10, :inline_format => true
      end
      stroke_bounds
    end

  end

  def coshh
    text_box "Supplied COSHH Information", size: 12, style: :bold, align: :left, :at => [0,386]
    bounding_box([0,372], :width => 524, :height => 180) do
      boxwidth = bounds.right - bounds.left
      boxheight = bounds.top - bounds.bottom
      stroke_bounds
      bounding_box([bounds.left+10 ,bounds.top-10], :width => boxwidth*0.5-20, :height => boxheight-20) do
        text "<b>Name of Solvent:</b>  #{@sample.coshh_name}", :size => 10, :inline_format => true
        text "<b>Description of Sample:</b>  #{@sample.coshh_desc}", :size => 10, :inline_format => true
        text "<b>Hazards and Procedures:</b>  #{@sample.coshh_info}", :size => 10, :inline_format => true
      end
      bounding_box([boxwidth*0.5+10 ,bounds.top-10], :width => boxwidth*0.5-20, :height => boxheight-20) do
        text "<b>Hazard Categories:</b>", :size => 10, :inline_format => true
        move_down 12
        for hazard in @hazards
          if @sample.hazards.include? hazard
            str = "#{hazard.hazard_desc} (#{hazard.hazard_abbr})"
            text str, :size => 10, :inline_format => true
          end
        end 

      end
    end


  end

  def coshh_summary

    text_box "Supplied COSHH Information", size: 8, style: :bold, align: :left, :at => [195,118]
    bounding_box([195,108], :width => 330, :height => 100) do
      boxwidth = bounds.right - bounds.left
      boxheight = bounds.top - bounds.bottom
      stroke_bounds
      bounding_box([bounds.left+10 ,bounds.top-10], :width => boxwidth*0.5-20, :height => boxheight-20) do
        text "<b>Name of Solvent:</b>  #{@sample.coshh_name}", :size => 8, :inline_format => true
          font_size = 8
        if (@sample.coshh_desc.split(/[^-a-zA-Z]/).size > 30)
          font_size = 6
        end
        text "<b>Description of Sample:</b>  #{@sample.coshh_desc}", :size => font_size, :inline_format => true
          font_size = 8
        if (@sample.coshh_info.split(/[^-a-zA-Z]/).size > 30)
          font_size = 6
        end
        text "<b>Hazards and Procedures:</b>  #{@sample.coshh_info}", :size => font_size, :inline_format => true
      end
      bounding_box([boxwidth*0.5+10 ,bounds.top-10], :width => boxwidth*0.5-20, :height => boxheight-20) do
        text "<b>Hazard Categories:</b>", :size => 8, :inline_format => true
        move_down 12
        font_size = 8
        if (@sample.hazards.count > 5)
          font_size = 6
        end
        if (@sample.hazards.count < 6)
          font_size = 8
        end
        for hazard in @hazards
          if @sample.hazards.include? hazard
            str = "#{hazard.hazard_desc} (#{hazard.hazard_abbr})"
            text str, :size => font_size, :inline_format => true
          end
        end
      end

    end
    font("Helvetica") do
      draw_text "School of Chemistry Crystallography Service, Newcastle University", :size => 6, :at => [195,0], :style => :italic
    end

  end
end
```

The rendering is done in this code by a few functions. For example, the
header function renders the main title of the page.
The `show_barcode` function renders a graphic of the barcode and also
typesets the sample code and barcode number above and below the graphic.
A temporary file is used to store the graphic so that it can be rendered.
The code is a mess and will be one of the first candidates to be more
robustly written if/when time permits.

Tweaking Group Leader Views and Permissions
===========================================
Needed to allow group leaders to view their groups samples individually
as well as in a list. Therefore amended the 
`must_be_creator_or_admin` function in
`app/controllers/samples_controller.rb` to allow this and changed the name
of the function to `must_be_creator_or_leader_or_admin`. This function
now returns true if the current user is a group leader and the sample he
wants to view belongs to his group. 
The `must_be_creator_or_leader_or_admin` function now looks like this:

```
  def must_be_creator_or_leader_or_admin
    sample = Sample.find(params[:id])
    return true if (user_signed_in? and (current_user.admin? or current_user==sample.user))
    return true if((sample.user.group_id == current_user.group_id) and current_user.leader?)
    session[:return_to] = request.request_uri
    redirect_to root_url,
             :alert =>
             "You must be the sample owner, sample group leader or an administrator to view this sample!" and return false
  end
```

The contoller code is amended near the top to now read:

```
  before_filter :must_be_creator_or_leader_or_admin, :only => :show
```

Finally, we amend the group index view to remove the links to edit and 
destroy since the group leader cannot apply these actions.

Simple Search
=============
Implemented a simple search by code for both admins on all samples and
group leaders on group samples. Used Ryan Bates' technique described in
Railscasts. The one change from RBs method was to keep the search logic
within the controller in order to still use the column sorting functions.
First, in the view templates for index and groupindex, the following code 
was added to provide a search box - note the GET method must be used and
also the `:name` parameter is set to `nil` so that the URL does not
get appended with a useless `commit=search` string:

```
<% form_tag samples_path, :method => 'get' do %>
  <p>
    <%= text_field_tag :search, params[:search] %>
    <%= submit_tag "Search", :name => nil %>
  </p>
<% end %>
```

In the controller, for the full index we amend the `@samples` assignment
as follows:

```
     @samples=Sample.find( :all,
                           :joins => [:flag, {:user => :group}],
                           :order => "#{sort_column} #{sort_direction}",
                           :conditions => ['code LIKE ?', "%#{params[:search]}%"])
```

and similarly for groupindex:

```
    @samples=Sample.where("(code LIKE '#{current_user.group.group_abbr}%') AND (code LIKE '%#{params[:search]}%')").joins(:flag, {:user => :group}).order("#{sort_column} #{sort_direction}")
```

This produces a useful search while still allowing column resorting!

Fixing Group Validation
=======================
Needed to force user to select a group on registration so added:

```
  validates_presence_of :group_id
```

to the `app/models/user.rb` file. This solved the problem.

E-Mail Notifiction
==================
Devise is well integrated with e-mail and merely requires the correct
settings for the local e-mail agent. On the production system
(`crystal.ncl.ac.uk`) this will be `sendmail`, but on the development
system, I use google smtp via my gmail account. The production settings
go in the file `config/environments/production.rb`:

```
  config.action_mailer.default_url_options = { :host => 'crystal.ncl.ac.uk' }
  config.action_mailer.delivery_method = :sendmail

```

and development settings go in `config/environments/development.rb`:

```
  config.action_mailer.default_url_options = { :host => 'localhost:3000' }
  config.action_mailer.delivery_method = :smtp
  config.action_mailer.smtp_settings = {
    :address              => "smtp.gmail.com",
    :port                 => "587",
    :domain               => "gmail.com",
    :user_name            => "<my gmail username> ",
    :password             => "<my gmail password>",
    :authentication       => "plain",
    :enable_starttls_auto => true
}
```

With these settings, devise seems to do its
stuff, although its email templates may need modification later. New
registrations and password resetting seem to work fine.

The next aspect is sample recepts and updates. For these we create a Sample
mailer with two templates:

```
rails g mailer sample_mailer sample_receipt sample_update
```

This generates a file `app/mailers/sample_mailer.rb`. This is edited to
contain the following:

```
class SampleMailer < ActionMailer::Base
  default :from => "Crystallography Service <ncrystal@ncl.ac.uk>"

  # Subject can be set in your I18n file at config/locales/en.yml
  # with the following lookup:
  #
  #   en.sample.sample_receipt.subject
  #
  def sample_receipt(sample)
    @sample = sample
    @greeting = "Hi"
    mail(:to => "#{sample.user.firstname} #{sample.user.lastname} <#{sample.user.email}>", :subject => "Crystallography Service: Analysis Request Acknowledgement")
  end

  # Subject can be set in your I18n file at config/locales/en.yml
  # with the following lookup:
  #
  #   en.sample.sample_update.subject
  #
  def sample_update(sample, old_flag)
    @sample = sample
    @old_flag = old_flag
    @greeting = "Hi"

    mail(:to => "#{sample.user.firstname} #{sample.user.lastname} <#{sample.user.email}>", :subject => "Crystallography Service: Sample Status Update Notification")
  end
end
```

The line with `default` sets the default `from` address. There are two
methods, one of which sends a confirmation email when a sample is first
submitted. The second method will send an email when a sample
status changes. These methods can now be used by the samples controller
as here in the case of the `create` action:

```
  def create
    # @sample = Sample.new(params[:sample])
    @sample = current_user.samples.build params[:sample]
    if @sample.save
      SampleMailer.sample_receipt(@sample).deliver
      redirect_to @sample, :notice => "Sample request registered. You will receive a receipt and confirmation via email."
    else
      render :action => 'new'
    end
  end
```

Note that the controller calls the `sample_receipt` method defined in
the `app/mailers/sample_mailer.rb` file. The `@sample` variable is
passed on to the appropriate view which is constructed prior to the
sending of the email.

The views are in the directory `app/views/sample_mailer`
in the files `sample_receipt.text.erb` and `sample_update.text.erb`. They
are designed as templates for text emails. For html you create files
with similar names but `text` replaced by `html`. A first attempt at this
produced the following template for `sample_receipt.html.erb`:

```
<p>
Dear <%="#{@sample.user.firstname} #{@sample.user.lastname}"%>
<p>
<p>
New Sample Submission Code: <%=@sample.code%> (your ref <%=@sample.userref%>)
</p>
<p>
your sample analysis request has been received. Please download a
receipt using the link below. Please quote the sample code in any
correspondence.
</p>
<p>
There is a tear-off slip at the bottom
of the receipt which you should attach to your sample.
You will be informed via email of any
changes in the status of your sample.
</p>
<p>
<%= link_to "Analysis Request Receipt", "#{sample_url(@sample, :host => 'localhost:3000')}.pdf" %>
</p>
<p>
Newcastle Crystallography Service
</p>
```

We also want to send an email when the status flag changes. We edit the
sample model code to initiate this:

```
  after_update :send_email_after_status_change

  def send_email_after_status_change
    if (self.flag_id_changed?)
      flag=Flag.find(self.flag_id_was)
      SampleMailer.sample_update(self, flag).deliver
    end
  end
```

where we have an after_update filter which checks for a change to the
status flag and calls the `SampleMailer.sample_update` function defined
in the file `app/mailers/sample_mailer.rb`. The code is shown here:

```
  def sample_update(sample, old_flag)
    @sample = sample
    @old_flag = old_flag
    @greeting = "Hi"

    mail(:to => "#{sample.user.firstname} #{sample.user.lastname} <#{sample.user.email}>", :subject => "Crystallography Service: Sample Status Update Notification")
  end
```

This function sends two arguments to the mailer (and ultimately the
email view templates. `@sample` contains the current (updated) sample
object and `@old_flag` contains the previous flag object.
This is then displayed as a view in an email by the following code
contained in the file `app/views/sample_mailer/sample_update.html.erb`.

```
<p>
Dear <%="#{@sample.user.firstname} #{@sample.user.lastname}"%>
<p>
<p>
This is to inform you that the status for your sample
<%=@sample.code%> (your ref <%=@sample.userref%>) has changed as follows:
</p>
<p>
<%="New Status: #{@sample.flag.name} (#{@sample.flag.description})"%>
</p>
<p>
<%="Old Status: #{@old_flag.name} (#{@old_flag.description})"%>
</p>
<p>
<%= link_to "Link to Full Sample Information", "#{sample_url(@sample, :host => 'localhost:3000')}" %>
</p>
<p>
Newcastle Crystallography Service
</p>
```

One final thing which is useful (maybe essential) for development work.
With many users you don't want to send emails to the real addresses - it
would be nice if all emails to users could go to a single convenient address
in development. This functionality can be provided by interceptors.
To set things up, first create a file in the top-level `lib` directory
called (say) `development_mail_interceptor.rb`. The contents of this
file are:

```
class DevelopmentMailInterceptor
  def self.delivering_email(message)
    message.subject = "[#{message.to}] #{message.subject}"
    message.to = "jphagon@gmail.com"
  end
end
```

This code sets up the required behaviour, redirecting all emails to
`jphagon@gmail.com`. 
Next we need to register the interceptor in an initializer file 
which we can do by creating a file called (say) `setup_mail.rb` in
the `config/initializers` directory.

```
require 'development_mail_interceptor' # put this in the lib directory
ActionMailer::Base.register_interceptor(DevelopmentMailInterceptor) if Rails.env.development?
```

Adding a Queue Page
===================
Added a simple queue page for samples bearing the 'SUBMITTED' flag. This is
visible to all users so contains only limited information:

* sample code
* user ref
* submission date/time
* priority number
* estimated wait time

The estimated wait time is based solely on the submission date. It could
be modified to include priority information later. The queue page is
implemented by adding a queue controller action to the samples controller:

```
  def queue
     @samples=Sample.find( :all,
       :joins => [:flag],
       :order => "created_at ASC",
       :conditions => [" flags.id = samples.flag_id AND flags.name = 'SUBMITTED'"])

  end
```

The associated view looks like this:

```
<% title "Current Sample Queue" %>
<p>
The estimated wait time is likely to be shorter if the priority
number is lower for multiple samples submitted on the same day.
</p>
<table >
  <tr>
    <th>Sample Code</th>
    <th>User Ref</th>
    <th>Submitted At</th>
    <th>Priority</th>
    <th>Wait Time</th>
  </tr>
  <% days = 1 %>
  <% for sample in @samples %>
    <tr>
      <td><%= sample.code %></td>
      <td><%= sample.userref %></td>
      <td><%= neat_time(sample.created_at) %></td>
      <td><%= sample.priority %></td>
      <td><%= pluralize(days, 'Day') %></td>
    </tr>
    <% days = days + 1 %>
    </tr>
  <% end %>
</table>
```
Also added a 'Sample Queue' link to the standard user tools menu.

Modifying 'My Samples' Page
===========================
Added PDF links to each sample entry in the file
`app/views/users/show.html.erb` via:

```
<td><%= link_to "PDF", sample_path(sample, :format => "pdf") %></td>
```

Modifying Pages Index
=====================
Used `truncate` to limit the amount of page data visible in the index:

```
<td><%= truncate(page.content, :length => 80) %></td>
```

Pagination
==========
Used will_paginate to do index pagination. This requires a version 
greater than 3.0.2. Once installed, need to do make the following
change to a `Sample.find` call:

```
Sample.page(params[:page]).per_page(ITEMS_PER_PAGE).find

```

Here's an example for the `queue` action:

```
  def queue
     @samples=Sample.page(params[:page]).per_page(ITEMS_PER_PAGE).find( :all,
       :joins => [:flag],
       :order => "created_at ASC",
       :conditions => [" flags.id = samples.flag_id AND flags.name = 'SUBMITTED'"])

  end
```

`ITEMS_PER_PAGE` is a global constant defined in
`config/environment.rb`:

```
# Load the rails application
require File.expand_path('../application', __FILE__)

# Initialize the rails application
SampleTracker::Application.initialize!
ITEMS_PER_PAGE = 10 # num items per page for will_paginate
```

The only modification to most views is the following entry near the top:

```
<%= will_paginate @samples %>
```

For special views with calculated column values in the view, may need to
take into account the page number. This was the case for the queue samples
view:

```
 </tr>
  <% page_num = params[:page].to_i > 0 ? params[:page].to_i : 1 %>
  <% days =  1 + (page_num - 1) * 5%>
  <% for sample in @samples %>
    <tr>
      <td><%= sample.code %></td>
      <td><%= sample.userref %></td>
      <td><%= neat_time(sample.created_at) %></td>
      <td><%= sample.priority %></td>
      <td><%= pluralize(days, 'Day') %></td>
    </tr>
    <% days = days + 1%>
    </tr>
```
where the wait time column value now depend on a combination of page
number and row, rather than just row as before.

For the user sample index, it was easier to have a separate view.
So, the former 'My Samples' link was changed to 'My Profile' and the
samples list removed from both the controller and view leaving just
a basic profile page.
Instead, a new `userindex` controller action was set up in the
samples controller, very similar to the groupindex action:

```
  def userindex
    @samples=Sample.page(params[:page]).per_page(ITEMS_PER_PAGE).where("(user_id = '#{current_user.id}') AND (code LIKE '%#{params[:search]}%')").joins(:flag, {:user => :group}).order("#{sort_column} #{sort_direction}")
#                          :joins => [:flag, {:user => :group}],
  end
```

A `before_filter` was set up using `must_be_creator_or_leader_or_admin`.
The view template was almost identical to that for the `groupindex`
action apart from the title.

Bar Code Search
===============
A special form was created for bar code searches. This was done by
adding a new samples controller action called `findbarcode`. The
controller code is as follows:

```
  def findbarcode
    @samples=Sample.where("(barcode =  '#{params[:search]}')").joins(:flag, {:user => :group})
  end
```

with access only to admins:

```
  before_filter :admin_required, :only => [:index, :findbarcode, :edit, :update, :destroy]
```

The view template looks like this:

```
<% title "Sample Bar Code Search" %>

<% form_tag "/samples/findbarcode/#{current_user.id}", 
    :method => 'get' do %>
  <p>
    <%= text_field_tag :search, params[:search] %>
    <%= submit_tag "Search", :name => nil %>
  </p>
<% end %>

<% if (@samples.size != 0) %>

<table class="pretty">
  <tr>
    <th><%= sortable "code", "Code" %></th>
    <th><%= sortable "userref", "Ref" %></th>
<!--    <th><%= sortable "params", "Parameters" %></th> -->
    <th><%= sortable "name", "Status" %></th>
    <th><%= sortable "created_at", "Submitted" %></th>
    <th><%= sortable "updated_at", "Updated" %></th>
    <th><%= sortable "priority", "Priority" %></th>
<!--    <th><%= sortable "powd", "Powd?" %></th> -->
<!--    <th><%= sortable "chiral", "Chiral?" %></th> -->
<!--    <th><%= sortable "cost_code", "Cost Code" %></th> -->
    <th><%= sortable "lastname", "User" %></th>
    <th><%= sortable "group_abbr", "Group" %></th>
  </tr>
  <% for sample in @samples %>
    <tr>
      <td><%= sample.code %></td>
      <td><%= sample.userref %></td>
<!--      <td><%= sample.params %></td> -->
      <td><%= sample.flag.name %></td>
      <td><%= neat_time(sample.created_at) %></td>
      <td><%= neat_time(sample.updated_at) %></td>
      <td><%= sample.priority %></td>
<!--      <td><%= sample.powd %></td> -->
<!--      <td><%= sample.chiral %></td> -->
<!--      <td><%= sample.cost_code %></td> -->
      <td><%= "#{sample.user.firstname} #{sample.user.lastname}"  %></td>
      <td><%= "#{sample.user.group.group_desc}"  %></td>
      <td><%= link_to "Show", sample %></td>
      <td><%= link_to "PDF", sample_path(sample, :format => "pdf") %></td>
<!--      <td><%= link_to "Edit", edit_sample_path(sample) %></td>
      <td><%= link_to "Destroy", sample, :confirm => 'Are you sure?', :method => :delete %></td> -->
      <td></td>
      <td></td>
    </tr>
  <% end %>
</table>

<% end %>
```

Note that no pagination is necessary because the search should find at
most a single sample since the barcode is unique.
Finally, added a link on the main 'Admin Tools' list in
`app/views/layouts/application.html.erb`:

```
  <div id="admin_nav">
    <% if user_signed_in? and current_user.admin?%>
      Admin Tools:
      <%= link_to 'Hazards', hazards_path %> |
      <%= link_to 'User Groups', groups_path %> |
      <%= link_to 'Assets', assets_path %> |
      <%= link_to 'Pages', pages_path %> |
      <%= link_to 'Popups', popups_path %> |
      <%= link_to 'Status Flags', flags_path %> |
      <%= link_to 'Samples', samples_path %> |
      <%= link_to 'Find Bar Code', :controller => "samples",
                                   :action => "findbarcode",
                                   :id => current_user.id %> |
      <%= link_to 'Users', '/user' %>
    <% else %>
    <% end %>
  </div>

BUGFIX: Removed before_filter on userindex
==========================================
The before_filter didn't work properly, and in any case seems
unnecessary. Even if the user types in the correct 'My samples' URL
for another user, it doesn't show because the :id part of the URL
is ignored anyway.

Tidying Up
==========
Changed wording at the top of the sample create/edit form view template
in `app/views/samples/_form.html.erb` to:

```
<b>Note:</b> a unique code and a barcode will be
automatically generated on submission of this form when a new sample
is created.
```

Also added the code string to the sample edit page title in
`app/views/samples/edit.html.erb`:

```
<% title "Edit Sample #{@sample.code}" %>
```

Added a '.pdf' extension to PDF file link in
`app/controllers/sample_controller.rb`:

```
  def show
    @hazards = Hazard.find(:all)
    @sample = Sample.find(params[:id])
    respond_to do |format|
      format.html
      format.pdf do
        pdf = SamplePdf.new(@sample)
        send_data pdf.render, filename: "sample_#{@sample.code}.pdf",
                              type: "application/pdf"

      end
    end
  end
```

Added a link to 'Edit' in the `findbarcode` view (since that's often
what you want to do when searching by barcode).

Introduced a global variable `MAIL_HOST` which is referred to in the
email view template files. This constant is then set in the
files `development.rb` and `production.rb` in the directory
`config/environments`. In the former case the value is 'localhost:3000'
and in the latter case it is 'crystal.ncl.ac.uk'. There may well be
a helper for this, which would be the correct way to do it, but at least
this does not require a manual change when shifting from development
mode to production mode.

Group 'Show' Page
=================
Decided to re-implement the Group 'show' action and views. Didi this by
using a `:has_many => :through` relation to relate groups to samples.
Then if a user is a group leader he can list group and sample information
via the groups controller rather than the contrived groupindex action in
the samples controller as used previously. This enables us to get all
the samples for a group simply via `@group.samples.all`.
The group controller is thus modified to contain:

```
  helper_method :sort_column, :sort_direction
  before_filter :admin_required, :only => [:index, :create, :new,
                                           :edit, :update, :destroy]
  before_filter :must_be_leader_or_admin, :only => :show

.
.
.

  def show
    @group = Group.find(params[:id])
    @samples=@group.samples.page(params[:page]).per_page(ITEMS_PER_PAGE).all( :joins => :flag,
    :order => "#{sort_column} #{sort_direction}")
  end

.
.
.

private

  def must_be_leader_or_admin
    @group = Group.find(params[:id])
    return true if (user_signed_in? and (current_user.admin? or (current_user.leader? and current_user.group == @group)))
    session[:return_to] = request.request_uri
    redirect_to root_url,
             :alert =>
             "You must be a leader for this group or an administrator to view group data!" and return false
  end

  def sort_column
    cols = Sample.column_names + Flag.column_names
    cols.include?(params[:sort]) ? params[:sort] : "code"
  end

  def sort_direction
    %w[asc desc].include?(params[:direction]) ? params[:direction] : "asc"
  end
```

The group model now has the statement:

```
  has_many :samples, :through => :users
```

and so, in the show view for groups we now have a samples listing:


```
<% title "Group" %>

<p>
  <strong>Group Abbreviation:</strong>
  <%= @group.group_abbr %>
</p>
<p>
  <strong>Group Description:</strong>
  <%= @group.group_desc %>
</p>

<h3><%="Samples List for this Group" %></h3>

<p>
<%= will_paginate @samples %>
</p>

<% if @samples.count > 0 %>
<p>
<table class="pretty">
  <tr>
    <th><%= sortable "code", "Code" %></th>
    <th><%= sortable "userref", "Ref" %></th>
    <th><%= sortable "params", "Params" %></th>
    <th><%= sortable "name", "Status" %></th>
    <th><%= sortable "created_at", "Submitted" %></th>
    <th><%= sortable "updated_at", "Updated" %></th>
    <th><%= sortable "priority", "Priority" %></th>
    <th><%= sortable "powd", "Powd?" %></th>
    <th><%= sortable "chiral", "Chiral?" %></th>
    <th><%= sortable "cost_code", "Cost Code" %></th>
  </tr>

  <% for sample in @samples %>
    <tr>
      <td><%= sample.code %></td>
      <td><%= sample.userref %></td>
      <td><%= sample.params %></td>
      <td><%= sample.flag.name %></td>
      <td><%= neat_time(sample.created_at) %></td>
      <td><%= neat_time(sample.updated_at) %></td>
      <td><%= sample.priority %></td>
      <td><%= sample.powd %></td>
      <td><%= sample.chiral %></td>
      <td><%= sample.cost_code %></td>
      <td><%= link_to "Show", sample %></td>
    </tr>
  <% end %>
</table>
</p>
<% else %>
<p>
This group has no samples!
</p>
<% end %>



<p>
  <%= link_to "Edit", edit_group_path(@group) %> |
  <%= link_to "Destroy", @group, :confirm => 'Are you sure?', :method => :delete %> |
  <%= link_to "View All", groups_path %>
</p>
```

Further Tweaking to Views
======================
Additionally added PDF links to most of the views which included sample
listings (but not the sample queue). Also added pagination to samples lists
in user and group views and cleaned up the HTML by putting pagination
statements and samples tables within paragraphs for clarity.

Adding an 'Enabled' Flag to User Accounts
=========================================
Did this via a standard migration:

```
class AddActiveToUser < ActiveRecord::Migration
  def self.up
    add_column :users, :active, :boolean, :default => true
  end

  def self.down
    remove_column :users, :active
  end
end
```

Here, I called the flag `active` but decided to rename this because I
thought (possibly incorrectly) that this flag clashed with some devise code.
So, I renamed it to `enabled` via another migration:

```
class RenameActiveFlagInUsers < ActiveRecord::Migration
  def self.up
    rename_column :users, :active, :enabled
  end

  def self.down
    rename_column :users, :enabled, :active
  end
end
```

Now, I added the following before_filter to the 
`application_controller.rb` file:

```
  before_filter :is_account_enabled?
.
.
.

  def is_account_enabled?
    if current_user.present? && !current_user.enabled?
      sign_out current_user
      flash[:error] = "Sorry! this account is currently disabled."
      redirect_to root_path
    end
  end
```

which prevents a user with a disabled (i.e. not enabled) account from
logging in.

Validations and User Friendly Field Headings
============================================
Needed an efficient way to make validation messages easier to understand
since the field names are rather terse. Did this by adding
the following code near the top of the sample model file to
map sample field names to more user-friendly versions. This automatically
maps labels like `:field` to its corresponding user-friendly form.

```
HUMANIZED_ATTRIBUTES = {

  :userref        => "your reference",
  :code           => "sample code",
  :cif            => "chemical formula",
  :synth          => "synthetic route diagram",
  :coshh_name     => "solvent name",
  :coshh_desc     => "sample description",
  :coshh_info     => "COSHH handling information",
  :params         => "parameters field",
  :reference      => "published reference",
  :zipdata        => "data file",
  :sampleimage    => "sample image file",
  :cost_code      => "cost centre code",

}

def self.human_attribute_name(attr, options={})

  HUMANIZED_ATTRIBUTES[attr.to_sym] || super

end
```

After this, the samples form was edited to refer back to the labels rather
than explicity type out a user string.

Sorting, Paging and Searching for User List
===================================
Sorting was done in a similar way to other index lists except that an
extra `sort_column` controller method was required. This was called
`sort_user_column`:

```
  def sort_user_column
    cols = User.column_names + Group.column_names
    cols.include?(params[:sort]) ? params[:sort] : "lastname"
  end
```

and the index method was altered:

```
  def index
    @users=User.page(params[:page]).per_page(ITEMS_PER_PAGE).find( :all,
      :joins => :group,
      :order => "#{sort_user_column} #{sort_direction}",
      :conditions => ['lastname LIKE ?', "%#{params[:search]}%"])
  end
```

The sort_direction helper was unchanged. Paging was added by
`will_paginate` as in earlier index listings. Searching was
also implemented as before on the lastname field of the user.
The code in the view was slightly different:

```
<% form_tag '/user', :method => 'get' do %>
  <p>
    <%= text_field_tag :search, params[:search] %>
    <%= submit_tag "Search", :name => nil %>
  </p>

<% end %>
```

Note that we explicitly put in the '/user' index path rather than use
the `user_path` method which does not work and gives
a routing error. This might be because
`user_path` is really referring to the devise users route rather
than the user (without the 's') index route. Putting the user
index route in explicitly solved the problem.

Some Additions to the Sample Model
==================================
Needed to add 3 extra fields to the sample model: a 'sensitivity' field
to indicate one (or more) things that the sample is sensitive to;
a 'storage requirements' field (e.g. bench, fridge, freezer, dark);
a general comments box for the user to add any extra details (for example
what kind of glassware the sample is stored in) thought to be relevant.

The first two of these will require extra models which we call
'sensitivity' and 'store'. The last one, merely requires an extra text
field in the sample model which we call 'comments'.
We create the new models via the usual nifty-scaffold generator:

```
rails generate nifty:scaffold Sensitivity name:string description:text

rails generate nifty:scaffold Store name:string description:text
```

Now, rather like hazards, it is possible that there could be more
than one storage type required per sample and also more than one
type of sensitivity per sample. This will require the setting up of
many-to-many relationships between the new models and the sample model.

We must therefore set up join tables for these possibilities.
So for sensitivities, we need:

```
rails generate migration create_samples_sensitivities
```

with the following content:

```
class CreateSamplesSensitivities < ActiveRecord::Migration
  def self.up
    create_table :samples_sensitivities, :id => false do |t|
      t.references :sample, :null => false
      t.references :sensitivity, :null => false
    end
  end

  def self.down
    drop_table :samples_sensitivities
  end
end
```

Smilarly, for stores, we need:

```
rails generate migration create_samples_stores
```

with the following content:

```
class CreateSamplesStores < ActiveRecord::Migration
  def self.up
    create_table :samples_stores, :id => false do |t|
      t.references :sample, :null => false
      t.references :store, :null => false
    end
  end

  def self.down
    drop_table :samples_stores
  end
end
```

Also, we need the following entries in the sample and store/sensitivity models
respectively (the files `sample.rb` and `sensitivity.rb`/`store.rb` in app/models):

```
  has_and_belongs_to_many :sensitivities # sample.rb
  has_and_belongs_to_many :stores # sample.rb

  has_and_belongs_to_many :samples # sensitivity.rb
  has_and_belongs_to_many :samples # store.rb
```

In the sample form, we can now add a set of checkboxes thus:

```
    <% for sensitivity in Sensitivity.find(:all) %>
    <div>
      <%= check_box_tag "sample[sensitivity_ids][]", sensitivity.id, @sample.sensitivities.include?(sensitivity) %>
      <%= sensitivity.description %>
    </div>
    <% end %>
```

NOTE: for the above to work, you need to set :sensitivity_ids in the
attr_accessible flag of the sample model:

```
class Sample < ActiveRecord::Base
  attr_accessible :sensitivity_ids, :hazard_ids, :code, :cif, :synth, :coshh_name, :coshh_desc, :coshh_info, :coshh_haz, :params, :status, :priority, :powd, :chiral, :cost_code, :barcode
  has_and_belongs_to_many :sensitivities
```

Finally, we add a comments field to the sample model:

```
rails generate migration add_comments_to_sample comments:text
```

All that remains to do is add these to the samples form view:

```
  <p>
    <%= f.label "Sample Sensitivity Information" %><br />
    <% for sensitivity in Sensitivity.find(:all) %>
    <div>
      <%= check_box_tag "sample[sensitivity_ids][]", sensitivity.id, @sample.sensitivities.include?(sensitivity) %>
      <%= "#{sensitivity.name}: #{sensitivity.description}" %>
    </div>
    <% end %>
  </p>

  <p>
    <%= f.label "Sample Storage Information" %><br />
    <% for store in Store.find(:all) %>
    <div>
      <%= check_box_tag "sample[store_ids][]", store.id, @sample.stores.include?(store) %>
      <%= "#{store.name}: #{store.description}" %>
    </div>
    <% end %>
  </p>

  <p>
    <%= f.label :comments %><br />
    <%= f.text_area :comments, :rows => 2, :title => popup_info('sample_comments') %>
  </p>
```

Validating Storage and Sensitivity Information
==============================================
We require that the user explicitly check at least one box in these categories.
The validation code for this is straightforward. We define two
custom validation methods and refer to them at the top of the
sample model file:

```
  validate :must_specify_sensitivity
  validate :must_specify_store
```

The methods look like this:

```
  def must_specify_sensitivity
    if (sensitivities.size == 0 )
      errors.add('', 'you must specify sample sensitivity')
    end
  end

  def must_specify_store
    if (stores.size == 0 )
      errors.add('', 'you must specify sample storage requirements')
    end
  end
```

In addition, we define one further validation in the sample model
requiring that if the user selects 'other' for either storage or sensitivity, 
they must have a non-blank entry in comments:

```
  def comment_must_not_be_blank_if_other_specified
    found_other = false
    for s in stores
      if (s.name == 'other')
        found_other = true
      end
    end
    for s in sensitivities
      if (s.name == 'other')
        found_other = true
      end
    end
    if ( found_other && ( comments =~ /^\s*$/ || comments.nil?) )
      errors.add('', "you have specified  'other' for either samples or storage - please give details in the comments box")
    end
  end
```

Of course, this doesn't stop people putting an entry in comments which
does not specify the storage or sensitivity when they have selected 'other'
but it at least prevents a blank entry if they do select 'other'.

User Switching for Admins
=========================
A very useful feature for admins is the ability to 'become' an ordinary
user quickly to check for problems or to submit samples on behalf of a
user. The code to do this is surprisingly simple. In the users controller
we just need to add the following code:

```
  def become
    return unless current_user.admin?
    # sign_in(:user, User.find(params[:id]))
    sign_in User.find(params[:id]), :bypass => true
    redirect_to root_url # or user_root_url
  end
```

Then, a link to `/users/become/[:id]` will automatically log an admin in as
that user. Note the `sign_in` call. The `:bypass => true` option is used
so that `last_sign_in_at` and `current_sign_in` aren't updated when 
becoming the user, otherwise the user may see that he has signed in 
recently and not understand why. However, if this behaviour is not
desired, the call can be replaced with the following:

```
sign_in(:user, User.find(params[:id]))
```

which will update the `last_sign_in_at` and `current_sign_in` values.
Now, we can add a 'Become' link to the user index view in
`app/views/user/index.html.erb`:      

```
<td><%= link_to "Become", "/users/become/#{user.id}" %></td>
```

For graceful error messages and a belt-and-braces approach, we also
add `:become` to the before filter in the users controller:

```
before_filter :admin_required, :only => [:index, :destroy, :become]
```

Updating the Samples Show Views
===============================
The extra samples fields required an update to the show views for
both the HTML and PDF cases. This was straightforward, an extension
of what was done previously for the hazards list. The PDF code was
further modified to make the code a little more compact and easier to
edit in future.

CSS Styling: Main Layout
========================
First styled the main layout as follows:

* A full-width top container for login status and possibly other data.
* A navigation menu down the left hand side. This stacks the user and
admin menus and has a fixed width of 150px.
* The main container section which shows sample lists etc.

First modified the existing css styling for the main object with
id 'container' and then added further ids 'top_container', 'admin_nav',
'user_nav' and 'nav_container'. 'nav-container' is a container for both
the admin and user navigation containers. Here is the relevant part of the
style file `public/stylesheets/application.css`): 

```
#top_container p{
  text-align: right;
  margin: 0px;
  padding: 0px;
}

#nav_container {
  width: 150px;
  float: left;
  margin-top: 10px;
}

#container {
/*  width: 75%;
    margin: 0 auto; */
  background-color: #FFF;
  padding: 20px 40px;
  border: solid 1px #999;
  margin-top: 10px;
  margin-left: 160px;
}

#user_nav {
  text-align: center;
}

#user_nav h3 {
  margin: 0;
  padding: 7px 5px;
  display: block;
  background-color: #666;
  color: #fff;
}

#user_nav ul {
  margin: 0;
  padding: 0;
  list-style: none;
  border-bottom: 1px solid #999;
}

#user_nav a {
  color: #000;
  font-size: 1em;
  text-transform: uppercase;
  text-decoration: none;
  border: 1px solid #999;
  border-bottom:none;
  padding: 7px 5px;
  display: block;
  background-color: #e7e7e7;
}
#user_nav a:hover {
  font-weight: bold;
  background: #fff;
}

#admin_nav {
  text-align: center;
}

#admin_nav h3 {
  margin: 0;
  padding: 7px 5px;
  display: block;
  background-color: #666;
  color: #fff;
}

#admin_nav ul {
  margin: 0;
  padding: 0;
  list-style: none;
  border-bottom: 1px solid #999;
}

#admin_nav a {
  color: #000;
  font-size: 1em;
  text-transform: uppercase;
  text-decoration: none;
  border: 1px solid #999;
  border-bottom:none;
  padding: 7px 5px;
  display: block;
  background-color: #e7e7e7;
}
#admin_nav a:hover {
  font-weight: bold;
  background: #fff;
}
```

This produces an acceptable menu down the left hand side. The login status
is now flush-right along the top and the page container is a variable width
and can fill the whole page if necessary.

Of course, this also necessitated some changes in the main layout file.
This is what the top of the layout file (`app/views/layouts/application.html.erb`) looks like now:

```
    <% if user_signed_in? %>
      <div id="top_container">
      <p>
      Signed in as <%= current_user.email %>. Not you?
      <%= link_to "Sign out", destroy_user_session_path, :method => :delete %>
      </p>
      </div>
  <div id="nav_container">
  <div id="user_nav">
      <h3>User Tools</h3>
      <ul>
        <li>
      <%= link_to 'My Profile', "/users/show/#{current_user.id}" %>
        </li>
        <li>
      <%= link_to 'My Samples', "/samples/userindex/#{current_user.id}" %>
        </li>
      <% if user_signed_in? and (current_user.admin? or current_user.leader?) %>
        <li>
        <%= link_to 'My Group Samples', :controller => "groups",
                                        :action => "show",
                                        :id => current_user.group.id %>
        </li>
      <% end %>
        <li>
        <%= link_to 'Sample Queue',     :controller => "samples",
                                        :action => "queue",
                                        :id => current_user.id %>
        </li>
        <li>
      <%= link_to 'Submit New Sample', new_sample_path %>
        </li>
        <li>
      <%= link_to 'Home', root_url %>
        </li>
      </ul>
    <% else %>
      <div id="top_container">
        <p>
      <%= link_to "Sign up", new_user_registration_path %> or
      <%= link_to "Sign in", new_user_session_path %>
        </p>
      </div>
    <% end %>
  </div>
.
.
.
```

CSS Styling: List Formatting
============================
For a model index page we add some code to do alternate colouring of
rows. There is a nice rails helper for this. For example, in the
samples listing view (in the part that loops through all the samples) the
code for a table row (`<tr>`) is replaced with:

```
    <tr class="<%= cycle :odd, :even %>">
```

Then all that is needed is to add a couple of entries in the stylesheet:

```
tr.even {
  background-color: #fff;
}

tr.odd {
  background-color:#eee;
}
```

We modify the other list views in the same way.

PDF Rendering Bugfix
====================
There was a problem in dealing with situations where a sample may not have
any COSHH information. This shouldn't happen, but may occur if old samples
are imported into the database. The `coshh_summary` method was changed to:

```
  def coshh_summary

    font_size = 8
    if (!@sample.coshh_info)
      if (@sample.coshh_info.split(/[^-a-zA-Z]/).size +
        @sample.comments.split(/[^-a-zA-Z]/).size > 60)
        font_size = 5
      end
    end
```

Other Page Enhancements
=======================
The samples listing is shortened by narrowing the priority field
and using a smaller font.
Added a basic set of static links to the nav menu.

Adding Pages to Main Menu
=========================
Decided to add an extra boolean variable to the pages model. This
variable, when selected would automatically add a link to the main
left hand menu for static pages.

```
rails generate migration add_menu_to_page menu:boolean
```

Now we add some extra CSS code for another class which we call
`menu_nav` with similar entries to `admin_nav` and `user_nav` which
we saw earlier. To process the pages we define a new helper method
called `create_menu` in `app/helpers/application_helper.rb`:

```
  def create_menu
    @pages = Page.find_all_by_menu(true)
      ulist = ''
    if (@pages)
      ulist = '<ul>'
      for page in @pages
        url = "/#{page.permalink}"
        ulist = ulist + "<li>#{link_to page.permalink, url}</li>"
      end
      ulist = ulist + '</ul>'
      ulist
    end
  end
```

This method creates a UL list of all those pages which have the
menu option ticked. The main layout code in
`app/views/layouts/application.html.erb` is modified to add these menu
items to the top of the left hand menu whether the user is logged in or
not (we don't mind an unregistered user seeing these pages):

```
  <div id="nav_container">
    <div id="menu_nav">
      <h3> Information </h3>
        <%= create_menu.html_safe %>
      </div>
```

The code above is added to the top of the menu that a signed-in user sees.
The same code is also added in the part where  a user is not logged in.
The same block of code appears twice in the view --- the logic really needs
to be changed so that it appears only once.

Ordering the Static Pages in the Menu
=====================================
The previous technique works well but has one flaw --- there is no way to
order the pages as they appear in the menu. The default ordering is simply
alphabetical. To get around this, we add an extra parameter to the page
model called `order`. This is an integer used to determine the order of
appearance of a static page in the menu. Low numbers will have priority
and if two pages have the same order number, then they will be sorted
alphabetically. So, we create another migration:

```
rails generate migration add_order_to_page order:integer
```

I realised later that calling this field `order` might conflict with some
of the ordering methods. So, via  a migration the name was changed to
`priority`. It is now a simple matter to change the helper code which
renders the top menu in the file `app/helpers/application_helper.rb`:

```
@pages = Page.find_all_by_menu(true, :order => 'priority')
```

This completes the menu customization.

More Minor View Changes and Global Variables
============================================
It seems sensible to add a link to the Textile documentation on the edit
page form. Since such links may appear in more than one place and are
liable to change, we first set these up in the `config/environment.rb` file
near the bottom for easy reference:

```
###################  SPECIFIC GLOBAL VARS ####################
TEXTILE_REF_URL = "http://redcloth.org/textile/"
TEXTILE_QUICK_REF_URL = "http://en.wikipedia.org/wiki/Textile_%28markup_language%29"
```

So, for example, in the page edit view, we add the following links:

```
  <%= link_to "Textile Reference Manual", TEXTILE_REF_URL :target => 'blank'%> |
  <%= link_to "Textile Quick Reference", TEXTILE_QUICK_REF_URL :target => 'blank'%>
```

The link to the textile quick reference page was removed from the page
show view (for administrators) since it's really only in edit mode that they
may need the textile reference links.

Tweaked some of the search buttons to indicate clearly which field is being
searched. In particular, the sample search buttons now have the label
'Search by Sample Code'.

Removed the 'Home' link from the 'User Tools' part of the menu since it now
appears in the 'Information' section at the top of the left hand menu.

Bugfix to User/Group Leader Search
=============================
There was a bug in the sample search for group leaders. To correct this,
the following method was employed. first, the controller code was altered
for the show action (`app/controllers/groups_controller.rb`):

```
  def show
    @group = Group.find(params[:id])

    @samples=Sample.page(params[:page]).per_page(ITEMS_PER_PAGE).where("(code LIKE '#{current_user.group.group_abbr}%') AND (code LIKE '%#{params[:search]}%')").joins(:flag, {:user => :group}).order("#{sort_column} #{sort_direction}")

  end
```

This adds the correct samples listing. Now, the view must be changed as well:

```
.
.
.
<h3><%="Samples List for this Group" %></h3>

<% form_tag "#{samples_path}/groupindex/#{@group.id}", :method => 'get' do %>
  <p>
    <%= text_field_tag :search, params[:search] %>
    <%= submit_tag "Search by Sample Code", :name => nil %>
  </p>

<% end %>
.
.
.
```

The key change is that we now point the form to the samples groupindex
action because it is this action which group leaders have permissions on,
not the overall samples index. The groupindex view is changed slightly to
reflect the fact that it is now created only as the result of a sample search.
The samples controller actions look like this:

```
  def groupindex
    @samples=Sample.page(params[:page]).per_page(ITEMS_PER_PAGE).where("(code LIKE '#{current_user.group.group_abbr}%') AND (code LIKE '%#{params[:search]}%')").joins(:flag, {:user => :group}).order("#{sort_column} #{sort_direction}")
#                          :joins => [:flag, {:user => :group}],
  end

  def userindex
    @samples=Sample.page(params[:page]).per_page(ITEMS_PER_PAGE).where("(user_id = '#{current_user.id}') AND (code LIKE '%#{params[:search]}%')").joins(:flag, {:user => :group}).order("#{sort_column} #{sort_direction}")
#                          :joins => [:flag, {:user => :group}],
  end
```

We do a similar thing for the user samples page --- in fact we merge it with
the user profile page and eliminate the separate user samples page. This makes
the left hand menu more compact.

Further View Refinements
========================
Replaced the sample and User listing links with icons and also added
some popup titles on some of the column headers where appropriate.
Added some styling to the sample form. 
Also styled the admin forms and improved the look of the
HTML version of the sample display.

Solved Problem with 'Delete' Operation in IE9
=============================================
Simple solution in the end --- solved by leaving all the devise stuff 
alone and simply adding an extra line in the `devise_scope :user` block in 
the `config/routes.rb` file:
```
  devise_scope :user do
    get '/login' => 'devise/sessions#new'
    get '/logout' => 'devise/sessions#destroy'
    get '/users/sign_out' => 'devise/sessions#destroy'
  end
```

Sample Introductory Text
========================
The introductory text at the top of the sample form is now editable via
a global variable stored in the `SPECIFIC GLOBAL VARS` section of
`config/environment.rb`:

```
SAMPLE_INTRO_TEXT = "a unique code and a barcode will be
automatically generated on submission of this form when a new sample
is created. For synthetic route files, please use either the JPG or PNG
bitmap image format.
Note further that for security reasons, if there are validation errors
in the form, you will have to re-select the names of uploaded files.
Also remeber to set the priority number, the form will not validate unless
you do this (if you are not going to submit several samples in a short
space of time we suggest setting the priority number to 1)."
```

Some Extra Sample Fields
========================
Added 3 simple text fields to the sample model: colour, size and shape.
These can be modified only by administrators but viewed by users.

Sample Queue Criteria
=====================
Samples appear in the queue unless their status flag is one of the
following:

* COMPLETED
* WITHDRAWN
* FAILED*

the latter meaning any ststus flag that begins with the string `FAILED`.
To do this, the `queue` action in the samples controller was changed to:

```
  def queue
     @samples=Sample.page(params[:page]).per_page(ITEMS_PER_PAGE).find( :all,
       :joins => [:flag],
       :order => "created_at ASC",
       :conditions => [" flags.id = samples.flag_id AND flags.name NOT LIKE '%%FAILED%%' AND flags.name NOT LIKE '%%COMPLETED%%' AND flags.name NOT LIKE '%%WITHDRAWN%%'"])
```

Note the double percent signs - need to do this because rails uses printf
internally and % on its own is a special character - so escape it with
two % signs.

Because the queue now contains samples which can have different status flags
(not just `SUBMITTED`, we add the status of the sample to the list:

```
      <td><%= sample.flag.name %></td>
```

Removing Authentication for Queue Display
=========================================
It was decided that the queue should be displayable without requiring
the user to sign in. This was easily accomplished by editing the
`before_filter` line in the samples controller:

```
  before_filter :authenticate_user!, :except => :queue
```

TODO: Generating Sample Data
============================
Use Faker to generate a large number of users and samples so that we can
test (among other things) pagination of sample listings etc.
Faker is installed via bundle in the usual way by placing the instruction
`gem 'faker'` in the development group of the Gemfile. Then need to
add the populate instructions in a rake tasks file which I've called
`sample_data.rake`. This file is placed in `lib/tasks`.
