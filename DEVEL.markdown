RSpec Install
=============

After initial bundle install, need to do an explicit rspec install:

```
rails generate rspec:install
```

which creates the rspec dir.

Static Pages
============
Following Ryan Bates' method, used his nifty-generators (installed via
a ruby gem) to produce a Page
model:

```
rails generate nifty:scaffold Page name:string permalink:string content:text
```

Also installed the RedCloth gem in the Gemfile:

```
gem 'RedCloth'
```

which allows administrators to use the Textile markup language in their
static pages.

Used the carrierwave gem to facilitate file upload (the rmagick gem is
also useful when using carrierwave (we'll use it to auto-generate thumbnail
images when the full images are uploaded):

```
gem "rmagick"
gem "carrierwave"
```

Then created a carrierwave uploader called Document:

```
rails g uploader Document
```

A new model called Asset was created for explicitly uploading files:

```
rails g nifty:scaffold Asset document:string description:text
```

The Sample Model
================
The model requires barcode generation for which the ruby gem 'barby'
is used. Note that there is a problem with the other well-known barcode
generator based on gnu barcode. 'barby' is self-contained and doesn't need
anything else - it's pure ruby. 


The sample model contains the following parts:

code        This is autogenerated and takes the form AAA-AAA-YY-1111 where
            the AAA represent 3 letter codes for supervisor and submitter
            respectively; the YY represents the year and the 1111 represents
            a number which is incremented for that supervisor but reset to
            zero at the start of each calendar year. [string]

cif	    The proposed chemical formula in cif format. [string]

synth	    The synthetic route. This will be usually a chemdraw file or
            possibly an image file specifying the details of the synthesis.
            This will rely on a carrierwave uploader called Synth. [string]

coshh_name  Name of solvent (if any). [string]

coshh_desc  Brief description of sample (e.g. organic amide) [string]

coshh_info  List of any known hazards and procedures in case of contact. [text]

coshh_haz   Chemical hazard information. This will take the form
            of a list selected from checkboxes. The checkboxes will be
            generated from a separate chemical hazard table. [string]

params      Unit cell parameters or CSD/Newcastle code for possible 
            by-products or previously obtained, unpublished results. [string]

status      The status flag of the sample. This can be changed only by
            crystallography staff and initially will have the value
            'SUBMITTED'. Probably best if other values are selected from
            a drop-down list generated from a status flags table. It is
            hidden on the form (but should appear in the show/edit
            views). [string]

priority    User-defined priority number in case of multiple sample
            submissions. [integer]

powd        Is powder diffraction required yes/no. [boolean]

chiral      Is molecule chiral? yes/no. [boolean]

cost_code   This will be set by crystallography staff and allocated by
            finance staff. It is hidden on the form and will be blank
            by default but will be visible in show/edit views. [string]

barcode     An auto-generated barcode. This will use the ruby gem
            'barby'. [string]

Again, use nifty-generators to generate the sample model:

```
rails generate nifty:scaffold Sample code:string cif:string synth:string coshh_name:string coshh_desc:string coshh_info:text coshh_haz:string params:string status:string priority:integer powd:boolean chiral:boolean cost_code:string barcode:string
```

don't forget to migrate the database:

```
rake db:migrate
```

Create the carrierwave uploader for synthetic route file:

```
rails g uploader Synth
```

Edit the /app/models/sample.rb file and add the line:

```
mount_uploader :synth, SynthUploader
```

this links the synth field with the carrierwave fileuploader.

Then change the new sample form code. First need to make the form multipart
because we're uploading an external file along with the other data:

```
<%= form_for @sample, :html => {:multipart => true} do |f| %>
```

and also change the text box entry for the synth field to a file selection box:

```
<%= f.file_field :document %>
```

Chemical Hazard Codes
=====================
Each sample can be associated with zero or more chemical hazard codes
and vice-versa (i.e. a many-to-many relationship). 
Potentially, these codes could vary
and new ones could come in, so we create a small table for this.
The table has two fields: hazard_desc and hazard_abbr the second field
being the standard abbreviation of the first.
As before, use nifty generators for this:

```
rails generate nifty:scaffold Hazard hazard_desc:string hazard_abbr:string
```

This unfortunately means that we need to alter the sample table because
coshh_haz doesn't need to be there - rails3 will handle the many-to-many
association for us.
Do this with a migration:

```
rails generate migration remove_hazard_from_sample
```

Edit the migration to contain the following code:

```
class RemoveHazardFromSample < ActiveRecord::Migration
  def self.up
    remove_column :samples, :coshh_haz
  end

  def self.down
    add_column :samples, :coshh_haz, :string
  end
end
```

We must also set up a join table via another migration:

```
rails generate migration create_samples_hazards
```

with the following content:

```
class CreateSamplesHazards < ActiveRecord::Migration
  def self.up
    create_table :hazards_samples, :id => false do |t|
      t.references :sample, :null => false
      t.references :hazard, :null => false
    end
  end

  def self.down
    drop_table :hazards_samples
  end
end
```

Also, we need the following entries in the sample and hazard models
respectively (the files sample.rb and hazard.rb in app/models):

```
  has_and_belongs_to_many :hazards # sample.rb

  has_and_belongs_to_many :samples # hazard.rb
```

In the sample form, we can now add a set of checkboxes thus:

```
    <% for hazard in Hazard.find(:all) %>
    <div>
      <%= check_box_tag "sample[hazard_ids][]", hazard.id, @sample.hazards.include?(hazard) %>
      <%= hazard.hazard_desc %>
    </div>
    <% end %>
```

NOTE: for the above to work, you need to set :hazard_ids in the
attr_accessible flag of the sample model:

```
class Sample < ActiveRecord::Base
  attr_accessible :hazard_ids, :code, :cif, :synth, :coshh_name, :coshh_desc, :coshh_info, :coshh_haz, :params, :status, :priority, :powd, :chiral, :cost_code, :barcode
  has_and_belongs_to_many :hazards
```

if you don't add :hazard_ids as attr_accessible then you'll get the
following error in the server log:

```
WARNING: Can't mass-assign protected attributes: hazard_ids
```

Image Processing
================
When images of synthetic routes are uploaded, we want to generate a
thumbnail version (while still retaining the original) and display the
thumbnail on the show page but which is hyperlinked to the full image.
To do this, we need rmagick (which is installed via a gem as described
earlier). Then we edit the carrierwave uploader class file in:

```
app/uploaders/image_uploader.rb
```

and edit/uncomment the thumbnail code already there to:

```
  version :thumb do
    process :resize_to_limit => [320, 240]
  end
```

this uses rmagick to resize the original image into a thumbnail version
for display. You will also need to uncomment the RMagick include statement
near the top of the app/uploaders/image_uploader.rb file.

```
  include CarrierWave::RMagick
```

Displaying the Barcode Graphic
==============================

Decided to use the Code39 standard. Need to first create a special
inline controller to actually display the barcode graphic (png). So, we
have this in the samples controller:

```
  def show_barcode

    require 'barby'
    require 'barby/barcode/code_39'
    require 'barby/outputter/png_outputter'
    #require 'barby/outputter/ascii_outputter'
    @sample = Sample.find(params[:id])

    barcode = Barby::Code39.new(@sample.barcode)

    # puts barcode.to_ascii #Implicitly uses the AsciiOutputter

    bcimage = barcode.to_png

    send_data bcimage, :type => 'image/png', :disposition => 'inline'

  end
```

We then have the following code in the samples 'show' view:

```
  <strong>Barcode:</strong>
  <%= @sample.barcode %><br />
  <%= image_tag url_for(:controller => "samples", :action => "show_barcode", :id => @sample.id) %>
```

We also need a route for this controller in config/routes.rb:

```
  match ':controller/:action/:id'
```

Create Table for Research Groups
================================
Here, we create a table for research groups (or any other groups) which
users will ultimately be linked with.

```
rails generate nifty:scaffold Group group_abbr:string group_desc:string
```

Now we want to limit the abbreviation string to 3 characters so we
create a new migration:

```
rails generate migration limit_group_abb
```

Then edit the migration file to contain:

```
class LimitGroupAbb < ActiveRecord::Migration
  def self.up
    change_column :groups, :group_abbr, :string, :limit => 3
  end

  def self.down
    change_column :groups, :group_abbr, :string, :limit => 255
  end
end
```

Add some validations for the group abbreviation:

```
  validates :group_abbr, :length => { :is => 3 }, :uniqueness => true
  validates :group_desc, :presence => true
  validates_format_of :group_abbr, :with => /[A-Z]{3}/
```

this restricts the abbreviation to a 3-capital letter unique string.

PDF Generation
==============

Decided to use PDFkit for this. First installed wkhtmltopdf by downloading
a static executable from the website and copying to /usr/local/bin and
/usr/bin (just to be sure). Next the Gemfile for PDFKit:

```
gem "pdfkit"
```

After the usual @bundle install@, added a line near the end of
the file @config/application.rb@:

```
    config.filter_parameters += [:password]
    config.middleware.use "PDFKit::Middleware"
  end
end
```

Then did a @rake middleware@ to check that PDFKit was installed
correctly. Now, appending @.pdf@ to a URL will render a PDF version
of that page. Unfortunately you can really only check this in production
mode because WEBrick is single-threaded (and still just displays the HTML).
You can test that the URL is accepted by the server however, even if it
doesn't display the HTML.

User Authentication with Devise
===============================
Followed Ryan Bates Railscast example. Added

```
gem 'devise', '1.4.9'
```

and then did a @bundle install@ followed by:

```
rails generate devise:install
```

note colon rather than underscore in the above command.
Then needed to add the following to the development environment file
@config/environments/development.rb@:

```
config.action_mailer.default_url_options = { :host => 'localhost:3000' }
```

For production, need to add a similar line to the
@config/environments/production.rb@ file, but with the name of the
actual machine replacing the @localhost:3000@ bit. You must also set an
explicit @root_url@ in the @config/routes.rb@ file such as:

```
root :to => "pages#home"
```

For this to work, also created a home controller action for the page model
in @app/controllers/pages_controller.rb@ (initially using the 'about'
permalink but eventually this will be the 'home' permalink:

```
  def home
    @page = Page.find_by_permalink('about')
  end
```

and a view in @app/views/pages/home.html.erb@ - this was almost identical to
the 'show' action view.

Also need to ensure you have flash messages in 
@app/views/layouts/application.html.erb@, e.g.:

```
<p class="notice"><%= notice %></p>
<p class="alert"><%= alert %></p>
```

This is achieved in the current application via some general flash code
in the view template (@app/views/layouts/application.html.erb@):

```
<% flash.each do |name, msg| %>
  <%= content_tag :div, msg, :id => "flash_#{name}" %>
<% end %>
```

After this, followed the user setup as explained by Ryan Bates (the devise 
docs also have clear instructions on how to do this).

Defining the User and Group Relationship
========================================
We need a one-to-many relationship between groups and users (a group has 
many users, but a user belongs to just one group. 
First, we must add a group_id integer field to the user model by creating
a migration as follows:

```
rails generate migration add_group_id_to_users group_id:integer
```

Also, we need the following entries in the user and group models
respectively (the files user.rb and group.rb in app/models):

```
  has_many :users # group.rb

  belongs_to :group # user.rb
```

The group_id field must be made accessible in the user model:

```
attr_accessible :email, :password, :password_confirmation, :remember_me, :group_id
```

We need to customise views in devise, so we first ask devise to generate files
for its default views (which are normally stored in the devise 'engine':

```
rails generate devise:views
```

This creates a lot of views which we can now edit to include groups.
The first files to change are the new user registration form and edit form:

```
app/views/devise/registrations/new.html.erb
app/views/devise/registrations/edit.html.erb
```

In the user form, we can now add a group select dropdown thus ( note that
the call to select is NOT preceded by the form object reference, i.e.
not f.select just select):

```
  <div><%= f.label "Group" %><br />
  <%= select(:user, :group_id, Group.all.collect {|g| [ g.group_desc, g.id ] },
    {:include_blank => 'None'}) %></div>
```
