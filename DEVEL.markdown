RSpec Install
=============

After initial bundle install, need to do an explicit rspec install:

```
rails generate rspec:install
```

which creates the rspec dir.

Static Pages
============
Following Ryan Bates' method, used his nifty-generators (installed via
a ruby gem) to produce a Page
model:

```
rails generate nifty:scaffold Page name:string permalink:string content:text
```

Also installed the RedCloth gem in the Gemfile:

```
gem 'RedCloth'
```

which allows administrators to use the Textile markup language in their
static pages.

Used the carrierwave gem to facilitate file upload (the rmagick gem is
also useful when using carrierwave (we'll use it to auto-generate thumbnail
images when the full images are uploaded):

```
gem "rmagick"
gem "carrierwave"
```

Then created a carrierwave uploader called Document:

```
rails g uploader Document
```

A new model called Asset was created for explicitly uploading files:

```
rails g nifty:scaffold Asset document:string description:text
```

The Sample Model
================
The model requires barcode generation for which the ruby gem 'barby'
is used. Note that there is a problem with the other well-known barcode
generator based on gnu barcode. 'barby' is self-contained and doesn't need
anything else - it's pure ruby. 


The sample model contains the following parts:

code        This is autogenerated and takes the form AAA-AA-YY-1111 where
            the AAA and AA represent 3 letter codes for group and submitter
            respectively; the YY represents the year and the 1111 represents
            a number which is incremented for that group but reset to
            zero at the start of each calendar year. [string]

cif	    The proposed chemical formula in cif format. [string]

synth	    The synthetic route. This will be usually a chemdraw file or
            possibly an image file specifying the details of the synthesis.
            This will rely on a carrierwave uploader called Synth. [string]

coshh_name  Name of solvent (if any). [string]

coshh_desc  Brief description of sample (e.g. organic amide) [string]

coshh_info  List of any known hazards and procedures in case of contact. [text]

coshh_haz   Chemical hazard information. This will take the form
            of a list selected from checkboxes. The checkboxes will be
            generated from a separate chemical hazard table. [string]

params      Unit cell parameters or CSD/Newcastle code for possible 
            by-products or previously obtained, unpublished results. [string]

status      The status flag of the sample. This can be changed only by
            crystallography staff and initially will have the value
            'SUBMITTED'. Probably best if other values are selected from
            a drop-down list generated from a status flags table. It is
            hidden on the form (but should appear in the show/edit
            views). [string]

priority    User-defined priority number in case of multiple sample
            submissions. [integer]

powd        Is powder diffraction required yes/no. [boolean]

chiral      Is molecule chiral? yes/no. [boolean]

cost_code   This will be set by crystallography staff and allocated by
            finance staff. It is hidden on the form and will be blank
            by default but will be visible in show/edit views. [string]

barcode     An auto-generated barcode. This will use the ruby gem
            'barby'. [string]

Again, use nifty-generators to generate the sample model:

```
rails generate nifty:scaffold Sample code:string cif:string synth:string coshh_name:string coshh_desc:string coshh_info:text coshh_haz:string params:string status:string priority:integer powd:boolean chiral:boolean cost_code:string barcode:string
```

don't forget to migrate the database:

```
rake db:migrate
```

Create the carrierwave uploader for synthetic route file:

```
rails g uploader Synth
```

Edit the /app/models/sample.rb file and add the line:

```
mount_uploader :synth, SynthUploader
```

this links the synth field with the carrierwave fileuploader.

Then change the new sample form code. First need to make the form multipart
because we're uploading an external file along with the other data:

```
<%= form_for @sample, :html => {:multipart => true} do |f| %>
```

and also change the text box entry for the synth field to a file selection box:

```
<%= f.file_field :document %>
```

Chemical Hazard Codes
=====================
Each sample can be associated with zero or more chemical hazard codes
and vice-versa (i.e. a many-to-many relationship). 
Potentially, these codes could vary
and new ones could come in, so we create a small table for this.
The table has two fields: hazard_desc and hazard_abbr the second field
being the standard abbreviation of the first.
As before, use nifty generators for this:

```
rails generate nifty:scaffold Hazard hazard_desc:string hazard_abbr:string
```

This unfortunately means that we need to alter the sample table because
coshh_haz doesn't need to be there - rails3 will handle the many-to-many
association for us.
Do this with a migration:

```
rails generate migration remove_hazard_from_sample
```

Edit the migration to contain the following code:

```
class RemoveHazardFromSample < ActiveRecord::Migration
  def self.up
    remove_column :samples, :coshh_haz
  end

  def self.down
    add_column :samples, :coshh_haz, :string
  end
end
```

We must also set up a join table via another migration:

```
rails generate migration create_samples_hazards
```

with the following content:

```
class CreateSamplesHazards < ActiveRecord::Migration
  def self.up
    create_table :hazards_samples, :id => false do |t|
      t.references :sample, :null => false
      t.references :hazard, :null => false
    end
  end

  def self.down
    drop_table :hazards_samples
  end
end
```

Also, we need the following entries in the sample and hazard models
respectively (the files sample.rb and hazard.rb in app/models):

```
  has_and_belongs_to_many :hazards # sample.rb

  has_and_belongs_to_many :samples # hazard.rb
```

In the sample form, we can now add a set of checkboxes thus:

```
    <% for hazard in Hazard.find(:all) %>
    <div>
      <%= check_box_tag "sample[hazard_ids][]", hazard.id, @sample.hazards.include?(hazard) %>
      <%= hazard.hazard_desc %>
    </div>
    <% end %>
```

NOTE: for the above to work, you need to set :hazard_ids in the
attr_accessible flag of the sample model:

```
class Sample < ActiveRecord::Base
  attr_accessible :hazard_ids, :code, :cif, :synth, :coshh_name, :coshh_desc, :coshh_info, :coshh_haz, :params, :status, :priority, :powd, :chiral, :cost_code, :barcode
  has_and_belongs_to_many :hazards
```

if you don't add :hazard_ids as attr_accessible then you'll get the
following error in the server log:

```
WARNING: Can't mass-assign protected attributes: hazard_ids
```

Image Processing
================
When images of synthetic routes are uploaded, we want to generate a
thumbnail version (while still retaining the original) and display the
thumbnail on the show page but which is hyperlinked to the full image.
To do this, we need rmagick (which is installed via a gem as described
earlier). Then we edit the carrierwave uploader class file in:

```
app/uploaders/synth_uploader.rb
```

and edit/uncomment the thumbnail code already there to:

```
  version :thumb do
    process :resize_to_limit => [320, 240]
  end
```

this uses rmagick to resize the original image into a thumbnail version
for display. You will also need to uncomment the RMagick include statement
near the top of the app/uploaders/image_uploader.rb file.

```
  include CarrierWave::RMagick
```

Displaying the Barcode Graphic
==============================

Decided to use the Code39 standard. Need to first create a special
inline controller to actually display the barcode graphic (png). So, we
have this in the samples controller:

```
  def show_barcode

    require 'barby'
    require 'barby/barcode/code_39'
    require 'barby/outputter/png_outputter'
    #require 'barby/outputter/ascii_outputter'
    @sample = Sample.find(params[:id])

    barcode = Barby::Code39.new(@sample.barcode)

    # puts barcode.to_ascii #Implicitly uses the AsciiOutputter

    bcimage = barcode.to_png

    send_data bcimage, :type => 'image/png', :disposition => 'inline'

  end
```

We then have the following code in the samples 'show' view:

```
  <strong>Barcode:</strong>
  <%= @sample.barcode %><br />
  <%= image_tag url_for(:controller => "samples", :action => "show_barcode", :id => @sample.id) %>
```

We also need a route for this controller in config/routes.rb:

```
  match ':controller/:action/:id'
```

Create Table for Research Groups
================================
Here, we create a table for research groups (or any other groups) which
users will ultimately be linked with.

```
rails generate nifty:scaffold Group group_abbr:string group_desc:string
```

Now we want to limit the abbreviation string to 3 characters so we
create a new migration:

```
rails generate migration limit_group_abb
```

Then edit the migration file to contain:

```
class LimitGroupAbb < ActiveRecord::Migration
  def self.up
    change_column :groups, :group_abbr, :string, :limit => 3
  end

  def self.down
    change_column :groups, :group_abbr, :string, :limit => 255
  end
end
```

Add some validations for the group abbreviation:

```
  validates :group_abbr, :length => { :is => 3 }, :uniqueness => true
  validates :group_desc, :presence => true
  validates_format_of :group_abbr, :with => /[A-Z]{3}/
```

this restricts the abbreviation to a 3-capital letter unique string.

PDF Generation
==============

Decided to use PDFkit for this. First installed wkhtmltopdf by downloading
a static executable from the website and copying to /usr/local/bin and
/usr/bin (just to be sure). Next the Gemfile for PDFKit:

```
gem "pdfkit"
```

After the usual `bundle install`, added a line near the end of
the file `config/application.rb`:

```
    config.filter_parameters += [:password]
    config.middleware.use "PDFKit::Middleware"
  end
end
```

Then did a `rake middleware` to check that PDFKit was installed
correctly. Now, appending `.pdf` to a URL will render a PDF version
of that page. Unfortunately you can really only check this in production
mode because WEBrick is single-threaded (and still just displays the HTML).
You can test that the URL is accepted by the server however, even if it
doesn't display the HTML.

User Authentication with Devise
===============================
Followed Ryan Bates Railscast example. Added

```
gem 'devise', '1.4.9'
```

and then did a `bundle install` followed by:

```
rails generate devise:install
```

note colon rather than underscore in the above command.
Then needed to add the following to the development environment file
`config/environments/development.rb`:

```
config.action_mailer.default_url_options = { :host => 'localhost:3000' }
```

For production, need to add a similar line to the
`config/environments/production.rb` file, but with the name of the
actual machine replacing the `localhost:3000` bit. You must also set an
explicit @root_url@ in the `config/routes.rb` file such as:

```
root :to => "pages#home"
```

For this to work, also created a home controller action for the page model
in `app/controllers/pages_controller.rb` (initially using the 'about'
permalink but eventually this will be the 'home' permalink:

```
  def home
    @page = Page.find_by_permalink('about')
  end
```

and a view in `app/views/pages/home.html.erb` - this was almost identical to
the 'show' action view.

Also need to ensure you have flash messages in 
`app/views/layouts/application.html.erb`, e.g.:

```
<p class="notice"><%= notice %></p>
<p class="alert"><%= alert %></p>
```

This is achieved in the current application via some general flash code
in the view template (`app/views/layouts/application.html.erb`):

```
<% flash.each do |name, msg| %>
  <%= content_tag :div, msg, :id => "flash_#{name}" %>
<% end %>
```

After this, followed the user setup as explained by Ryan Bates (the devise 
docs also have clear instructions on how to do this).

Defining the User and Group Relationship
========================================
We need a one-to-many relationship between groups and users (a group has 
many users, but a user belongs to just one group. 
First, we must add a group_id integer field to the user model by creating
a migration as follows:

```
rails generate migration add_group_id_to_users group_id:integer
```

Also, we need the following entries in the user and group models
respectively (the files user.rb and group.rb in app/models):

```
  has_many :users # group.rb

  belongs_to :group # user.rb
```

The group_id field must be made accessible in the user model:

```
attr_accessible :email, :password, :password_confirmation, :remember_me, :group_id
```

We need to customise views in devise, so we first ask devise to generate files
for its default views (which are normally stored in the devise 'engine':

```
rails generate devise:views
```

This creates a lot of views which we can now edit to include groups.
The first files to change are the new user registration form and edit form:

```
app/views/devise/registrations/new.html.erb
app/views/devise/registrations/edit.html.erb
```

In the user form, we can now add a group select dropdown thus ( note that
the call to select is NOT preceded by the form object reference, i.e.
not f.select just select):

```
  <div><%= f.label "Group" %><br />
  <%= select(:user, :group_id, Group.all.collect {|g| [ g.group_desc, g.id ] },
    {:include_blank => 'None'}) %></div>
```

Modifying the User Model
========================
Needed to add a few more fields to the devise user model. First added a
boolean 'admin' field to denote whether a user is an administrator.
Did this via a migration as usual:

```
rails generate migration add_admin_to_user admin:boolean
```

Wanted to make the default for this @false@ so modified the migration
file by adding a `:default => false` directive to `add-column`:

```
class AddAdminToUser < ActiveRecord::Migration
  def self.up
    add_column :users, :admin, :boolean, :default => false
  end

  def self.down
    remove_column :users, :admin
  end
end
```

Then did a `rake db:migrate` and restarted the server. Then did a similar
thing to add `firstname` and `lastname` text fields. After this, edited
the user model file to make these new fields attribute accessible
in `app/models/user.rb`:

```
class User < ActiveRecord::Base
  # Include default devise modules. Others available are:
  # :token_authenticatable, :encryptable, :confirmable, :lockable, :timeoutable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable

  # Setup accessible (or protected) attributes for your model
  attr_accessible :email, :password, :password_confirmation, :remember_me, :group_id, :firstname, :lastname, :admin
end
```

Unfortunately, attempting to regenerate the devise views with:

```
rails generate devise:views
```

doesn't add entries for the new fields. Worse, it deletes the references
to the user group in the existing forms as created previously. Hence,
the new fields needed to be added to the forms:

```
  <div><%= f.label 'First Name' %><br />
  <%= f.text_field :firstname %></div>

  <div><%= f.label 'Last Name' %><br />
  <%= f.text_field :lastname %></div>
```

Note that the admin entry was not added, since it defaults to `false`.
It will (eventually) be available only for an administrator to edit.
The group reference was reinstated as before.

Defining the Sample and User Relationship
========================================
We need a one-to-many relationship between users and samples (a user has
many samples, but a sample belongs to just one user).
First, we must add a user_id integer field to the sample model by creating
a migration as follows:

```
rails generate migration add_user_id_to_samples user_id:integer
```

Also, we need the following entries in the sample and user models
respectively (the files sample.rb and user.rb in app/models):

```
  has_many :samples # user.rb

  belongs_to :user # sample.rb
```

The user_id field must be made accessible in the sample model:

```
  attr_accessible :hazard_ids, :code, :cif, :synth, :coshh_name, :coshh_desc, 
                  :coshh_info, :coshh_haz, :params, :status, :priority, 
                  :powd, :chiral, :cost_code, :barcode, :user_id
```

When creating a sample, the user is associated with it via this simple
piece of code in the create function of the sample controller (note the
current_user function supplied by devise):

```
  def create
    # @sample = Sample.new(params[:sample])
    @sample = current_user.samples.build params[:sample]
    if @sample.save
      redirect_to @sample, :notice => "Successfully created sample."
    else
      render :action => 'new'
    end
  end
```

Basic Refinement of Views
=========================
Next, refine some of the views. For example, the samples index really
needs to show only a few basic things - so we strip off things such
as the reaction pathway image and add a column to show the user who
submitted the sample and his research group.
It is easy to add a link to a user and group in the main samples index:

```
<td><%= "#{sample.user.firstname} #{sample.user.lastname}"  %></td>
<td><%= "#{sample.user.group.group_desc}"  %></td>
```

Auto-Generation of Sample Code
==============================
Neede to auto-generate the sample code string which takes the following format:

```
AAA-AA-YY-1111
```

the AAA represent 3 letter codes for supervisor and submitter
respectively; the YY represents the year and the 1111 represents
a number which is incremented for that supervisor but reset to
zero at the start of each calendar year. The AAA part is taken from the
three letter group abbreviation and the AA part is taken from the
user initials. the year is trivial and a bit of code is needed to generate
the 4-digit trailing number. The code to do this goes in the controller
rather than the model, since it relies on pulling information from the
user and group tables. Here is the code in the samples controller file:

```
  def make_sample_code
    x = Time.now
    grp = current_user.group.group_abbr
    usr = current_user.firstname.first.upcase +
           current_user.lastname.first.upcase
    yr  = x.strftime('%g')
    num = create_sample_num
    "#{grp}-#{usr}-#{yr}-#{num}"
  end

  def create_sample_num
    x = Time.now
    yr = x.strftime('%g')
    grp = current_user.group.group_abbr
    samps = Sample.where('code LIKE ?', "#{grp}-%-#{yr}-%").all
    if (samps.length > 0)
      str = samps.last.code
      last_num = /\d\d\d\d$/.match(str)[0].to_i
      new_num = last_num + 1
      # now an amazing idiom to convert to 4 digit string!
      return "%04d" % new_num
    else
      return "%04d" % 1
    end
  end
```

These functions are then used later in the 'new' function:

```
  def new
    @sample = Sample.new
    @sample.code = make_sample_code
  end
```

View and Controller Permissions: Making a Start
===============================================

First, we change the permissions on the semi-static pages by making the
Edit/Destroy etc links disappear for all users (whether signed-in or not)
except when a user is signed in and is an administrator. This needs only
to be done for the `home.html.erb` and `show.html.erb` views.
Here's the code we use:

```
<% if user_signed_in? %>

<% if current_user.admin? %>
<p>
  <%= link_to "Edit", edit_page_path(@page) %> |
  <%= link_to "Destroy", @page, :confirm => 'Are you sure?', :method => :delete %> |
  <%= link_to "View All", pages_path %> |
  <%= link_to "Input Help", "http://en.wikipedia.org/wiki/Textile_%28markup_language%29", :target => "_blank" %>
</p>

<% else %>
<p>
</p>
<% end %>

<% end %>
```

Of course, this just prevents the links being seen --- we still need to
protect the controllers. Do this by defining a before filter
called `admin_required` in the `application_controller.rb` file:

```
  def admin_required
    return true if user_signed_in? and current_user.admin?
    session[:return_to] = request.request_uri
    redirect_to root_url,
             :alert => 
             "You must be an administrator to do this!" and return false
  end
```

We then make use of this in the pages controller file:

```
  before_filter :admin_required, :only => [ :new, :create, :index, :edit,
                                            :update, :destroy ]
```

In this way, we protect the semi-static pages from being edited
by an unauthorized user.

Setting up a Status Flag Table
==============================
It was decided to set up a special table to hold status flag strings. The
table is very simple, consisting of a string field and a text field
to hold the status flag and some brief explanatory text.
As usual, RB's nifty generators were used:

```
rails generate nifty:scaffold Flag name:string description:text
```

We need a one-to-many relationship between status flags and samples 
(a flag can be associated with many samples, but a sample has just one 
status flag at any one time.
First, we must add a flag_id integer field to the sample model by creating
a migration as follows:

```
rails generate migration add_flag_id_to_samples flag_id:integer
```

Also, we need the following entries in the sample and flag models
respectively (the files `sample.rb` and `flag.rb` in `app/models`):

```
  has_many :samples # flag.rb

  belongs_to :flag # sample.rb
```
We now remove `:status` from the `attr_accessible` flag of the sample model
as well as its validation line from `app/models/sample.rb`.
Of course, we must now also remove the status field from the sample model.
Do this with a migration:

```
rails generate migration remove_status_from_sample
```

Edit the migration to contain the following code:

```
class RemoveHazardFromSample < ActiveRecord::Migration
  def self.up
    remove_column :samples, :status
  end

  def self.down
    add_column :samples, :status, :string
  end
end
```

Forcing a Default Status Flag for a New Sample
==============================================
This seemed a sensible thing to do, so a migration was applied. The
migration file had the following content:

```
class AddDefaultValueForStatusToSample < ActiveRecord::Migration
  def self.up
    change_column :samples, :flag_id, :integer, :default => 1, :null => false
  end

  def self.down
    change_column :samples, :flag_id, :integer
  end
end
```

Adding User sample Listing on Edit User Page
===========================================
This is achieved by editing the `app/views/devise/registrations/edit.html.erb`
page with the following code:

```
<h3><%="My Samples" %></h3>

<table>
  <tr>
    <th>Code</th>
    <th>Params</th>
    <th>Status</th>
    <th>Update</th>
    <th>Priority</th>
    <th>Powd</th>
    <th>Chiral</th>
    <th>Cost Code</th>
    <th>Group</th>
  </tr>
  <% for sample in @user.samples %>
    <tr>
      <td><%= sample.code %></td>
      <td><%= sample.params %></td>
      <td><%= sample.flag.name %></td>
      <td><%= sample.updated_at %></td>
      <td><%= sample.priority %></td>
      <td><%= sample.powd %></td>
      <td><%= sample.chiral %></td>
      <td><%= sample.cost_code %></td>
      <td><%= link_to "Show", sample %></td>
    </tr>
  <% end %>
</table>
```

Adding an Explicit Users Controller
===================================
To enable users to see a 'show' page, needed to add a users controller
(since we're using a 'user' model in devise (`app/controllers/users_controller.rb`):

```
class UsersController < ApplicationController
  def show
    @user = current_user
  end
end
```

and then construct an appropriate view listing the user's details and his
list of samples (`app/views/users/show.html.erb`):

```
<h2><%= "#{@user.firstname} #{@user.lastname}"%></h2>


<p>
  <strong>Group</strong>
  <%= "#{@user.group.group_desc}(#{@user.group.group_abbr})" %>
</p>
<p>
  <strong>EMail</strong>
  <%=@user.email %>
</p>
<p>
  <strong>Administrator?</strong>
  <%=@user.admin? ? 'yes' : 'no' %>
</p>

<h3><%="Samples" %></h3>

<table>
  <tr>
    <th>Code</th>
    <th>Params</th>
    <th>Status</th>
    <th>Update</th>
    <th>Priority</th>
    <th>Powd</th>
    <th>Chiral</th>
    <th>Cost Code</th>
    <th>Group</th>
  </tr>
  <% for sample in @user.samples %>
    <tr>
      <td><%= sample.code %></td>
      <td><%= sample.params %></td>
      <td><%= sample.flag.name %></td>
      <td><%= sample.updated_at %></td>
      <td><%= sample.priority %></td>
      <td><%= sample.powd %></td>
      <td><%= sample.chiral %></td>
      <td><%= sample.cost_code %></td>
      <td><%= link_to "Show", sample %></td>
    </tr>
  <% end %>
</table>

<%= link_to "Back", :back %>
```

Adding Some Admin Links
=======================
Administrators will need to add/edit pages, assets, research groups, hazards,
samples and status flags. To put links to the edit menus for these, we
edit the `app/views/layouts/application.html.erb` file. To achieve what we
want, we edit the following container in the layout:

```
  <div id="user_nav">
    <% if user_signed_in? %>
      Signed in as <%= current_user.email %>. Not you?
      <%= link_to "Sign out", destroy_user_session_path, :method => :delete %>
      <br />
      <%= link_to 'My Samples', "/users/show/#{current_user.id}" %>
    <% else %>
      <%= link_to "Sign up", new_user_registration_path %> or
      <%= link_to "Sign in", new_user_session_path %>
    <% end %>
  </div>
```

Note that we have used the user show controller action and view.
Also add an extra layout for admins:

```
  <div id="admin_nav">
    <% if user_signed_in? and current_user.admin?%>
      Admin Tools:
      <%= link_to 'Hazards', hazards_path %> |
      <%= link_to 'User Groups', groups_path %> |
      <%= link_to 'Assets', assets_path %> |
      <%= link_to 'Pages', pages_path %> |
      <%= link_to 'Status Flags', flags_path %> |
      <%= link_to 'Samples', samples_path %>
    <% else %>
    <% end %>
  </div>
```

Restricting Users
=================
To stop users editing samples, we remove the Edit|Destroy|View All options
at the bottom of the show page if they are not an admin. Then we also
restrict their ability to do this completely (even if they know the
correct action URL) in the controller.
So, in `app/views/samples/show.html.erb` we have:

```
<% if current_user.admin? %>
<p id="pdf_link">
  <%= link_to "Edit", edit_sample_path(@sample) %> |
  <%= link_to "Destroy", @sample, :confirm => 'Are you sure?', :method => :delete %> |
  <%= link_to "View All", samples_path %>
</p>
<% end %>
```
In the samples controller we add the following:

```
before_filter :admin_required :only => [:edit, :update, :destroy]
```

To prevent users viewing samples other than their own, we have this
in the samples controller:

```
  before_filter :must_be_creator_or_admin, :only => :show
```

with the filter code in the same file (since it's specific to the samples
controller):

```
private

  def must_be_creator_or_admin
    sample = Sample.find(params[:id])
    return true if (user_signed_in? and (current_user.admin? or current_user==sample.user))
    session[:return_to] = request.request_uri
    redirect_to root_url,
             :alert =>
             "You must be the sample owner or an administrator to view this sample!" and return false
  end
```

Notice, it's in a private block to be safe.

Sorting Columns
===============
It is important that the samples column be easily sortable. Used Ryan
Bates' method described in Railscasts 228. Unfortunately, this is not
the full answer because it only works on 'native' fields and not 
fields in related tables. For this I added some extra code using
SQL instructions.

First in the samples controller I added two private helper methods:

```
  def sort_column
    cols = Sample.column_names + Flag.column_names + Group.column_names + User.column_names
    cols.include?(params[:sort]) ? params[:sort] : "code"
  end

  def sort_direction
    %w[asc desc].include?(params[:direction]) ? params[:direction] : "asc"
  end
```

To make these accessible within views, they must explicity be labelled
as helper methods at the beginning of the controller code:

```
class SamplesController < ApplicationController
  helper_method :sort_column, :sort_direction
```

The first helper defines a set of columns over which we want to sort.
In this case, the list includes columns from the Flag, Group and User
tables as well as the Sample table. In the URL, one column will be
tagged as a sort column - if the column in the URL is not one of those
in the cols list, then the sort column will default to 'code'.

The second helper sets either a descending or ascending order - this
will alternate with successive clicks on the link. 
The sort column is selected by clicking on the header
which then send a URL of the form:

```
http://server/samples?direction=<asc|desc>&sort=<col>
```

The index function in the samples controller is re-written as:

```
  def index
     @samples=Sample.all( :joins => [:flag, {:user => :group}],
                          :order => "#{sort_column} #{sort_direction}")
  end
```

Note that the SQL ordering is set using the helpers and we have done an
inner join on the samples data so we can access the external tables
and their columns.

The index view in the file `app/views/samples/index.html.erb` now has
these entries in the header region:

```
<table class="pretty">
  <tr>
    <th><%= sortable "code", "Code" %></th>
<!--    <th><%= sortable "params", "Parameters" %></th> -->
    <th><%= sortable "name", "Status" %></th>
    <th><%= sortable "created_at", "Submitted" %></th>
    <th><%= sortable "updated_at", "Updated" %></th>
    <th><%= sortable "priority", "Priority" %></th>
<!--    <th><%= sortable "powd", "Powd?" %></th> -->
<!--    <th><%= sortable "chiral", "Chiral?" %></th> -->
<!--    <th><%= sortable "cost_code", "Cost Code" %></th> -->
    <th><%= sortable "lastname", "User" %></th>
    <th><%= sortable "group_abbr", "Group" %></th>
  </tr>
```

Here we use a helper called `sortable` to set up the appropriate links.
This helper is defined in `app/helpers/application_helper.rb` since
it is fairly generic:

```
module ApplicationHelper

  def sortable(column, title = nil)
    title ||= column.titleize
    css_class = column == sort_column ? "current #{sort_direction}" : nil
    direction = column == sort_column && sort_direction == "asc" ? "desc" : "asc"
    link_to title, {:sort => column, :direction => direction}, {:class => css_class}
  end

  def neat_time(date)
     date.strftime("%d/%m/%Y") + date.strftime("(%I:%M%P)")
  end

end
```

Note also the function `neat_time` which is used for displaying 'neat'
timestamps in tables.
Finally, added some CSS code to display an up/down arrow to indicate
both the current ordered column and its sorting direction. This is
in the file `public/stylesheets/application.css`:

```
table.pretty {
  border-collapse: collapse;
}

.pretty td, .pretty th {
  padding: 4px 10px;
}

.pretty th .current {
  padding-right: 12px;
  background-repeat: no-repeat;
  background-position: right center;
}
.pretty th .asc {
  background-image: url(/images/up_arrow.gif);
}

.pretty th .desc {
  background-image: url(/images/down_arrow.gif);
}
```

We need to do something similar in the 'My Samples' page for each user.
There are some subtle differences however. First, here is the controller
code for the user model:

```
class UsersController < ApplicationController

helper_method :sort_column, :sort_direction

  def show
    @user = current_user
    s = @user.samples
    @samples=s.all( :joins => :flag,
                    :order => "#{sort_column} #{sort_direction}")

  end

private

  def sort_column
    cols = Sample.column_names + Flag.column_names
    cols.include?(params[:sort]) ? params[:sort] : "code"
  end

  def sort_direction
    %w[asc desc].include?(params[:direction]) ? params[:direction] : "asc"
  end

end
```

We have introduced the same helper functions as before but `sort_column`
is slightly different because we only need to sort on fields from the
sample and flag tables. We must also define a samples list which is
done with a similar join as before. Now the samples section on the user
show page looks like this:

```
<h3><%="Samples" %></h3>
<% if @user.samples.count > 0 %>
<table class="pretty">
  <tr>
    <th><%= sortable "code", "Code" %></th>
    <th><%= sortable "params", "Params" %></th>
    <th><%= sortable "name", "Status" %></th>
    <th><%= sortable "created_at", "Submitted" %></th>
    <th><%= sortable "updated_at", "Updated" %></th>
    <th><%= sortable "priority", "Priority" %></th>
    <th><%= sortable "powd", "Powd?" %></th>
    <th><%= sortable "chiral", "Chiral?" %></th>
    <th><%= sortable "cost_code", "Cost Code" %></th>
  </tr>
  <% for sample in @samples %>
    <tr>
      <td><%= sample.code %></td>
      <td><%= sample.params %></td>
      <td><%= sample.flag.name %></td>
      <td><%= neat_time(sample.created_at) %></td>
      <td><%= neat_time(sample.updated_at) %></td>
      <td><%= sample.priority %></td>
      <td><%= sample.powd %></td>
      <td><%= sample.chiral %></td>
      <td><%= sample.cost_code %></td>
      <td><%= link_to "Show", sample %></td>
    </tr>
  <% end %>
</table>
<% else %>
<p>
You have no samples!
</p>
```

Amazingly, it all seems to work!

Additions to sample Model
=========================
Added a text string as a user reference. restrict this to be an alphanumeric
string with no spaces (validation). The migration file looks like this:

```
class AddUserrefTo_sample < ActiveRecord::Migration
  def self.up
    add_column :samples, :userref, :string, :default => nil
  end

  def self.down
    remove_column :samples, :userref
  end
end
```

Note the default is nil, but the validation process in the model
(`app/models/sample.rb`) will require this to be changed:

```
  validates :userref,    :format => {
    :with     => %r{^[A-Z,a-z,0-9]+$},
    :message  => 'must be alphanumeric sequence of characters without spaces.'
  }
```

Finally, need to add the userref field as attribute_accessible in the
user model.

Decided to remove the default value for userref so change this
with a migration:

```
class ChangeUserrefDefaultIn_sample < ActiveRecord::Migration
  def self.up
    change_column :samples, :userref, :string
  end

  def self.down
    change_column :samples, :userref, :string, :default => nil
  end
end
```

CRUD Interface to User Model
============================
Devise doesn't create a CRUD interface by default. We create one by following the devise docs and
the excellent summary by "Brandon Martin":http://zyphmartin.com/blog/manage-users-with-devise-and-cancan.
We will also make use of Ryan Bates' `cancan` gem for some authorization here. We add cancan to the
Gemfile and do a bundle install. After installing cancan, need to create an `Ability` class. Do this
by typing:

```
rails g cancan:ability
```

which creates a file `app/models/ability.rb`. This file is used by cancan to define abilities. At present,
we follow Brandon Martin with the following setup:

```
class Ability
  include CanCan::Ability

  def initialize(user)
   if user.admin?
     can :manage, :all
   else
     can :read, :all
   end
end
```

We will probably add to this later. Cancan assumes that there is a `current_user` method - no problem
since we're using devise.

For the CRUD interface first thing to do is set up the correct routes. 
Here's what we need in the `config/routes.rb` file:

```
  devise_for :users

  devise_scope :user do
    get '/login' => 'devise/sessions#new'
    get '/logout' => 'devise/sessions#destroy'
  end

  resources :user, :controller => "user"
```

Previously we had just `resources :users`, but now this is changed to a `:user` resource (singular) and a 
`devise_scope` directive.

Next, we need to create the `user` controller in `app/controllers/user_controller.rb`. We list it here in full:

```
class UserController < ApplicationController

  helper_method :sort_column, :sort_direction

  before_filter :authenticate_user!
  before_filter :must_be_user_or_admin, :only => [:show, :edit, :update]
  before_filter :admin_required, :only => [:index, :destroy]

  load_and_authorize_resource

  def index
    @users = User.all
  end

  def new
    @user = User.new
  end

  def create
    @user = User.new(params[:user])
    if @user.save
      flash[:notice] = "Successfully created User."
      redirect_to root_path
    else
      render :action => 'new'
    end
  end

  def show
    @user = User.find(params[:id])
    s = @user.samples
    @samples=s.all( :joins => :flag,
    :order => "#{sort_column} #{sort_direction}")
  end

  def edit
    @user = User.find(params[:id])
  end

  def update
    @user = User.find(params[:id])
    params[:user].delete(:password) if params[:user][:password].blank?
    params[:user].delete(:password_confirmation) if params[:user][:password].blank? and params[:user][:password_confirmation].blank?
    if @user.update_attributes(params[:user])
      flash[:notice] = "Successfully updated User."
      redirect_to root_path
    else
      render :action => 'edit'
    end
  end

  def destroy
    @user = User.find(params[:id])
    if @user.destroy
      flash[:notice] = "Successfully deleted User."
      redirect_to root_path
    end
  end

private

  def sort_column
    cols = Sample.column_names + Flag.column_names
    cols.include?(params[:sort]) ? params[:sort] : "code"
  end

  def sort_direction
    %w[asc desc].include?(params[:direction]) ? params[:direction] : "asc"
  end

  def must_be_user_or_admin
    user = User.find(params[:id])
    return true if (user_signed_in? and (current_user.admin? or current_user==user))
    session[:return_to] = request.request_uri
    redirect_to root_url,
             :alert =>
             "You must be the relevant user or an administrator to view or edit this user's details!" and return false
  end

end
```

Now, in `app/views/user` we add the following view templates:

```
edit.html.erb  _form.html.erb  index.html.erb  new.html.erb  show.html.erb
```

Here is the content of the various files.

`_form.html.erb`
================
```
<%= f.error_messages %>

<p><%= f.label "First Name" %><br />
<%= f.text_field :firstname %></p>

<p><%= f.label "last Name" %><br />
<%= f.text_field :lastname %></p>

<p><%= f.label :email %><br />
<%= f.text_field :email %></p>

  <div><%= f.label "Group" %><br />
  <%= select(:user, :group_id, Group.all.collect {|g| [ g.group_desc, g.id ] },
    {:include_blank => 'None'}) %></div>

<p>
<%= label_tag(:admin, "Administrator?") %>
<%= f.check_box(:admin) %>
</p>

<p><%= f.label :password %><br />
<%= f.password_field :password %></p>

<p><%= f.label :password_confirmation %><br />
<%= f.password_field :password_confirmation %></p>

<p><%= f.submit "Submit" %></p>
```

`edit.html.erb`
===============
```
% title "Edit User" %>

<%= form_for @user, :url => user_path do |f| %>
  <%= render :partial => 'form', :locals => { :f => f } %>
<% end %>
```

`index.html.erb`
================
```
<% title "Users" %>

<table>
  <tr>
    <th>First Name</th>
    <th>Last name</th>
    <th>Group</th>
  </tr>
  <% for user in @users %>
    <tr>
      <td><%= user.firstname %></td>
      <td><%= user.lastname %></td>
      <td><%= user.group.group_desc %></td>
      <td><%= link_to "Show", user %></td>
      <td><%= link_to "Edit", edit_user_path(user) %></td>
      <td><%= link_to "Destroy", user, :confirm => 'Are you sure?', :method => :delete %></td>
    </tr>
  <% end %>
</table>

<p><%= link_to "New User", new_user_path %></p>
```

`new.html.erb`
==============
```
<% title "New User" %>

<%= form_for @user, :url => user_index_path do |f| %>
  <%= render :partial => 'form', :locals => { :f => f } %>
<% end %>
```

`show.html.erb`
===============
```
<h2><%= "#{@user.firstname} #{@user.lastname}"%></h2>


<p>
  <strong>Group</strong>
  <%= "#{@user.group.group_desc} (#{@user.group.group_abbr})" %>
</p>
<p>
  <strong>EMail</strong>
  <%=@user.email %>
</p>
<p>
  <strong>Administrator?</strong>
  <%=@user.admin? ? 'yes' : 'no' %>
</p>

<h3><%="Samples" %></h3>
<% if @user.samples.count > 0 %>
<table class="pretty">
  <tr>
    <th><%= sortable "code", "Code" %></th>
    <th><%= sortable "userref", "Ref" %></th>
    <th><%= sortable "params", "Params" %></th>
    <th><%= sortable "name", "Status" %></th>
    <th><%= sortable "created_at", "Submitted" %></th>
    <th><%= sortable "updated_at", "Updated" %></th>
    <th><%= sortable "priority", "Priority" %></th>
    <th><%= sortable "powd", "Powd?" %></th>
    <th><%= sortable "chiral", "Chiral?" %></th>
    <th><%= sortable "cost_code", "Cost Code" %></th>
  </tr>
 <% for sample in @samples %>
    <tr>
      <td><%= sample.code %></td>
      <td><%= sample.userref %></td>
      <td><%= sample.params %></td>
      <td><%= sample.flag.name %></td>
      <td><%= neat_time(sample.created_at) %></td>
      <td><%= neat_time(sample.updated_at) %></td>
      <td><%= sample.priority %></td>
      <td><%= sample.powd %></td>
      <td><%= sample.chiral %></td>
      <td><%= sample.cost_code %></td>
      <td><%= link_to "Show", sample %></td>
    </tr>
  <% end %>
</table>
<% else %>
<p>
You have no samples!
</p>
<% end %>

<%= link_to "Back", :back %>
```

Note that the show form also shows the user's samples and that all of the pages, where appropriate, use the
column sorting tricks first used earlier.

Additions to Sample Model
========================
Added a field `zipdata` via a migration called
`add_zipdata_to_sample`. This is for a data file upload supplied by
an administrator after a sample has been analyzed. Used carrierwave
as previously with an uploader called `Zipdata` generated via:

```
rails g uploader Zipdata
```

and an extra entry to the `app/models/sample.rb` file:

```
mount_uploader :zipdata, ZipdataUploader
```

Changed the sample show/edit views and sample form accordingly.
As with the status flag, only an administrator can change this field.

Also added a field `sampleimage` via a migration called
`add_sampleimage_to_sample`. This is an image of the sample which is
uploaded after analysis by crystallography staff. 
Used carrierwave as previously with an uploader called `Sampleimage` 
generated via:

```
rails g uploader Sampleimage
```

and an extra entry to the `app/models/sample.rb` file:

```
mount_uploader :sampleimage, SampleimageUploader
```

We also create a thumbnail image (as with the synthetic route image file)
by making appropriate edits (described earlier in the synthetic
route image case) to the file:

```
app/uploaders/sampleimage_uploader.rb
```

Note that as ever, we must add any new fields that are editable to the
attribute accessible list in the file `app/models/sample.rb`:

```
class Sample < ActiveRecord::Base
  attr_accessible :hazard_ids, :code, :cif, :synth, :coshh_name, :coshh_desc, 
                  :coshh_info, :coshh_haz, :params, :priority, :powd, :chiral, 
                  :cost_code, :barcode, :user_id, :flag_id, :userref, 
                  :zipdata, :sampleimage
```



As with the zip data file
the sample show/edit views and sample form are changed accordingly.
Only an administrator can change this field.

Adding a DOI Reference Field
============================
This field allows the administrator to add a link to a reference in which
the structure has been published. This will take the form (usually) of
a DOI link. We start with a migration

```
rails generate migration add_reference_to_sample
```

Adding a Help Popups Table
==========================
This is a table of help strings. The idea is that administrators can
add arbitrary help strings which can be made to popup in some forms.
Initially, only the sample submission form will use these, but in
principle, any form can do so.
As usual, RB's nifty generators were used:

```
rails generate nifty:scaffold Popup name:string description:text
```

In the file `app/helpers/samples_helper.rb` we define a function to
display the popup description text:

```
  def popup_info( ref_str )
    if (p = Popup.find_by_name( ref_str ))
      p.description
    end
  end
```

and in the sample form, we have entries such as:

```
  <p>
    <%= f.label 'Your Ref' %><br />
    <%= f.text_field :userref, :title => popup_info('sample_yourref')%>
  </p>
```

This will display a popup box showing the popup description text, in this
case corresponding to the `sample_yourref` popup name. It is
recommended when using popups that a consistent naming convention is
adopted. In this case we have used `<model>_<field>` as the naming
convention for the popup.

Adding Group Leader Status
==========================
We add an extra boolean field to the User model to indicate that the
user is a 'group leader'. At present, all this does is allow such users
to look at ALL the samples submitted by a group, not just their own.
Additionally, they will receive e-mails when any group sample is
submitted or updated. This was achieved by adding an appropriate
migration to add a new field `leader` to the user model.

A new controller action called `groupindex` was added to the sample 
controller. This lists all the samples of the group to which the user
belongs. However, only group leaders can execute this action:

```
  def groupindex
    @samples=Sample.where("code LIKE '#{current_user.group.group_abbr}%'").joins(:flag, {:user => :group}).order("#{sort_column} #{sort_direction}")
#                          :joins => [:flag, {:user => :group}],
  end
```

Note that we have relied on comparing the sample code string to the
group abbreviation string belonging to the group of the current user.
This is OK because such abbreviation strings are unique.
A before filter called `must_be_leader_or_admin` was also added to
restrict access to this new controller:

```
  def must_be_leader_or_admin
    return true if (user_signed_in? and (current_user.admin? or current_user.leader?))
    session[:return_to] = request.request_uri
    redirect_to root_url,
             :alert =>
             "You must be a group leader or an administrator to view all group samples!" and return false
  end
```

At the top of the controller, we add the line:

```
  before_filter :must_be_leader_or_admin, :only => :groupindex
```

In the file `app/views/layouts/application.html.erb` we add some code to
display a link to the group samples index if the user is a group leader:

```
     <% if user_signed_in? and (current_user.admin? or current_user.leader?) %>
        <%= link_to 'My Group Samples', :controller => "samples",
                                        :action => "groupindex",
                                        :id => current_user.id %> |
      <% end %>
```

Note that strictly the `:id` parameter is not necessary, but is passed
to satisfy the routing requirements.

Redoing PDF output
==================
Decided to switch to Prawn. After installing Prawn via an entry in the 
Gemfile, the following was added to the file
`config/initializers/mime_types.rb `:

```
Mime::Type.register "application/pdf", :pdf
```

Only the sample 'show' action will initially have PDF support.
To enable the support, we change the 'show' code to:
```
  def show
    @hazards = Hazard.find(:all)
    @sample = Sample.find(params[:id])
    respond_to do |format|
      format.html
      format.pdf do
        pdf = SamplePdf.new(@sample)
        send_data pdf.render, filename: "sample_#{@sample.code}",
                              type: "application/pdf"

      end
    end
  end
```

The code has been modified with a `respond_to` directive which includes
pdf. At the end of the pdf response, the pdf output is rendered via
`send_data` to a file called `sample_<sample code>.pdf`.
To keep the controller code clean, most of the work is handled by a new
class called `SamplePdf` defined in the file `app/pdfs/order_pdf.rb`.
The `app/pdfs` directory was created first. the contents of this file
are as follows:

```
class SamplePdf < Prawn::Document
  
  def initialize(sample)
    super(page_size: "A4")
    @sample = sample
    @hazards = Hazard.find(:all)
    header
    structure
    sample_code
    coshh
    scissor_line
    show_barcode
    coshh_summary
      
  end

  def header
    nbsp = Prawn::Text::NBSP
      text "Newcastle Crystallography Service", font: "Helvetica", size: 30, style: :bold, align: :center
      text "Bedson Building#{nbsp}#{nbsp} " + 
           "<font name='ZapfDingbats' size='12'>F#{nbsp}#{nbsp}#{nbsp}</font>" + 
           "#{nbsp}#{nbsp}Newcastle University#{nbsp}#{nbsp}" + 
           "<font name='ZapfDingbats' size='12'>#{nbsp}#{nbsp}F#{nbsp}#{nbsp}</font>" + 
           "#{nbsp}#{nbsp}NE1 7RU", size: 16, 
             align: :center, :inline_format => true

    move_down 10
    stroke do
      horizontal_rule
    end
  end

  def sample_code
    text_box "Sample Code: #{@sample.code}", size: 16, style: :bold, align: :left, :at => [0,bounds.top-84]
    move_up 16
    text_box "Your Ref: #{@sample.userref}", size: 16, style: :bold, align: :right, :at => [250,bounds.top-84]
    intro_str = "Please check the details on this receipt. " +
                "Changes can be made only by Crystallography staff." +
                "Please use the tear-off slip at the bottom of the page and " +
                "attach it to your sample. You will be automatically " +
                "informed via e-mail of any changes to your sample status."
    text_box intro_str, size: 10, size: 10, :at => [0,bounds.top-104]
  end

  def show_barcode

    require 'tempfile'
    require 'barby'
    require 'barby/barcode/code_39'
    require 'barby/outputter/png_outputter'
    #require 'barby/outputter/ascii_outputter'

    barcode = Barby::Code39.new(@sample.barcode)

    # puts barcode.to_ascii #Implicitly uses the AsciiOutputter

    pagewidth = bounds.right - bounds.left
    bounding_box([0,108], :width => pagewidth) do

      font("Courier" ) do
        draw_text "#{@sample.code}", size: 14, style: :bold, :at => [32,cursor+3]
      end

      temp_file = Tempfile.new(['bc', '.png'])

      temp_file.write barcode.to_png(:margin => 0)
      temp_file.close

      image temp_file.path

      temp_file.close(true)

      bc_str = @sample.barcode.gsub(/(.{1})(?=.)/, '\1 \2')
    

      font("Courier" ) do
        draw_text "#{bc_str}", size: 12, style: :bold, :at => [7,cursor-10]
      end
    end

  end

  def scissor_line
    vmiddle=(bounds.top + bounds.bottom)*0.5
    hmiddle=(bounds.left + bounds.right)*0.5
    pagewidth = bounds.right - bounds.left
    bounding_box([0,144], :width => pagewidth) do
      dash(5, :space => 5, :phase => 3)
      stroke do
        pad(20) {
          font("ZapfDingbats", :size => 28) do
            draw_text "$", :at => [hmiddle,cursor]
          end
          move_up 10
          horizontal_rule
        }
      end
      undash
    end
  end

  def structure

    pagewidth = bounds.right - bounds.left
    boxwidth = pagewidth*0.5 - 5
    boxheight = 0.75*boxwidth
  # 
  # This next bit gives the absolute path name of the structure image
  #
    strucfile = Rails.root.to_s + '/public' + @sample.synth_url.to_s
  #
    text_box "Proposed Structure and Synthetic Route", size: 12, style: :bold, align: :left, :at => [0,bounds.top-168]
    text_box "Sample Details and Requirements", size: 12, style: :bold, align: :left, :at => [boxwidth+10,bounds.top-168]

    bounding_box([0,bounds.top-182], :width => boxwidth, :height => boxheight) do
      image strucfile, :position => :center, :height => boxheight*0.9, :width => boxwidth*0.9
    stroke_bounds
    end
    bounding_box([boxwidth+10 ,bounds.top-182], :width => boxwidth, :height => boxheight*0.25-5) do
      bounding_box([5 ,bounds.top-5], :width => boxwidth-10, :height => boxheight-10) do
        text "<b>Powder Diffraction Required?</b> #{@sample.powd ? 'Yes' : 'No'}", :size => 10, :inline_format => true
        text "<b>Chiral Structure?</b> #{@sample.chiral ? 'Yes' : 'No'}", :size => 10, :inline_format => true
        text "<b>Your Priority Number:</b> #{@sample.priority}", :size => 10, :inline_format => true
      end
      stroke_bounds
    end
    text_box "User Details", size: 12, style: :bold, align: :left, :at => [boxwidth+10,bounds.top-248]
    bounding_box([boxwidth+10 ,bounds.top-262], :width => boxwidth, :height => boxheight*0.7 -22) do
      bounding_box([5 ,bounds.top-5], :width => boxwidth-10, :height => boxheight-10) do
        text "<b>Submission Date:</b> #{@sample.created_at}", :size => 10, :inline_format => true
        text "<b>Submitted By:</b> #{@sample.user.firstname} #{@sample.user.lastname}", :size => 10, :inline_format => true
        text "<b>Research Group:</b>  #{@sample.user.group.group_desc}", :size => 10, :inline_format => true
        text "<b>Contact E-Mail:</b>  #{@sample.user.email}", :size => 10, :inline_format => true
        text "<b>Cost Centre Code:</b> #{@sample.cost_code}", :size => 10, :inline_format => true
        text "<b>Assigned Bar Code:</b> #{@sample.barcode}", :size => 10, :inline_format => true
      end
      stroke_bounds
    end

  end

  def coshh
    text_box "Supplied COSHH Information", size: 12, style: :bold, align: :left, :at => [0,386]
    bounding_box([0,372], :width => 524, :height => 180) do
      boxwidth = bounds.right - bounds.left
      boxheight = bounds.top - bounds.bottom
      stroke_bounds
      bounding_box([bounds.left+10 ,bounds.top-10], :width => boxwidth*0.5-20, :height => boxheight-20) do
        text "<b>Name of Solvent:</b>  #{@sample.coshh_name}", :size => 10, :inline_format => true
        text "<b>Description of Sample:</b>  #{@sample.coshh_desc}", :size => 10, :inline_format => true
        text "<b>Hazards and Procedures:</b>  #{@sample.coshh_info}", :size => 10, :inline_format => true
      end
      bounding_box([boxwidth*0.5+10 ,bounds.top-10], :width => boxwidth*0.5-20, :height => boxheight-20) do
        text "<b>Hazard Categories:</b>", :size => 10, :inline_format => true
        move_down 12
        for hazard in @hazards
          if @sample.hazards.include? hazard
            str = "#{hazard.hazard_desc} (#{hazard.hazard_abbr})"
            text str, :size => 10, :inline_format => true
          end
        end 

      end
    end


  end

  def coshh_summary

    text_box "Supplied COSHH Information", size: 8, style: :bold, align: :left, :at => [195,118]
    bounding_box([195,108], :width => 330, :height => 100) do
      boxwidth = bounds.right - bounds.left
      boxheight = bounds.top - bounds.bottom
      stroke_bounds
      bounding_box([bounds.left+10 ,bounds.top-10], :width => boxwidth*0.5-20, :height => boxheight-20) do
        text "<b>Name of Solvent:</b>  #{@sample.coshh_name}", :size => 8, :inline_format => true
        text "<b>Description of Sample:</b>  #{@sample.coshh_desc}", :size => 8, :inline_format => true
        text "<b>Hazards and Procedures:</b>  #{@sample.coshh_info}", :size => 8, :inline_format => true
      end
      bounding_box([boxwidth*0.5+10 ,bounds.top-10], :width => boxwidth*0.5-20, :height => boxheight-20) do
        text "<b>Hazard Categories:</b>", :size => 8, :inline_format => true
        move_down 12
        for hazard in @hazards
          if @sample.hazards.include? hazard
            str = "#{hazard.hazard_desc} (#{hazard.hazard_abbr})"
            text str, :size => 8, :inline_format => true
          end
        end
      end
      indent(5) do
        text "<i>School of Chemistry Crystallography Service, Newcastle University</i>", :size => 8, :inline_format => true
      end
    end
  end


end
```

The rendering is done in this code by a few functions. For example, the
header function renders the main title of the page.
The `show_barcode` function renders a graphic of the barcode and also
typesets the sample code and barcode number above and below the graphic.
A temporary file is used to store the graphic so that it can be rendered.

Tweaking Group Leader Views and Permissions
===========================================
Needed to allow group leaders to view their groups samples individually
as well as in a list. Therefore amended the 
`must_be_creator_or_admin` function in
`app/controllers/samples_controller.rb` to allow this and changed the name
of the function to `must_be_creator_or_leader_or_admin`. This function
now returns true if the current user is a group leader and the sample he
wants to view belongs to his group. 
The `must_be_creator_or_leader_or_admin` function now looks like this:

```
  def must_be_creator_or_leader_or_admin
    sample = Sample.find(params[:id])
    return true if (user_signed_in? and (current_user.admin? or current_user==sample.user))
    return true if((sample.user.group_id == current_user.group_id) and current_user.leader?)
    session[:return_to] = request.request_uri
    redirect_to root_url,
             :alert =>
             "You must be the sample owner, sample group leader or an administrator to view this sample!" and return false
  end
```

The contoller code is amended near the top to now read:

```
  before_filter :must_be_creator_or_leader_or_admin, :only => :show
```

Finally, we amend the group index view to remove the links to edit and 
destroy since the group leader cannot apply these actions.

Simple Search
=============
Implemented a simple search by code for both admins on all samples and
group leaders on group samples. Used Ryan Bates' technique described in
Railscasts. The one change from RBs method was to keep the search logic
within the controller in order to still use the column sorting functions.
First, in the view templates for index and groupindex, the following code 
was added to provide a search box - note the GET method must be used and
also the `:name` parameter is set to `nil` so that the URL does not
get appended with a useless `commit=search` string:

```
<% form_tag samples_path, :method => 'get' do %>
  <p>
    <%= text_field_tag :search, params[:search] %>
    <%= submit_tag "Search", :name => nil %>
  </p>
<% end %>
```

In the controller, for the full index we amend the `@samples` assignment
as follows:

```
     @samples=Sample.find( :all,
                           :joins => [:flag, {:user => :group}],
                           :order => "#{sort_column} #{sort_direction}",
                           :conditions => ['code LIKE ?', "%#{params[:search]}%"])
```

and similarly for groupindex:

```
    @samples=Sample.where("(code LIKE '#{current_user.group.group_abbr}%') AND (code LIKE '%#{params[:search]}%')").joins(:flag, {:user => :group}).order("#{sort_column} #{sort_direction}")
```

This produces a useful search while still allowing column resorting!

Fixing Group Validation
=======================
Needed to force user to select a group on registration so added:

```
  validates_presence_of :group_id
```

to the `app/models/user.rb` file. This solved the problem.

E-Mail Notifiction
==================
Devise is well integrated with e-mail and merely requires the correct
settings for the local e-mail agent. On the production system
(`crystal.ncl.ac.uk`) this will be `sendmail`, but on the development
system, I use google smtp via my gmail account. The production settings
go in the file `config/environments/production.rb`:

```
  config.action_mailer.default_url_options = { :host => 'crystal.ncl.ac.uk' }
```

and development settings go in `config/environments/development.rb`:

```
  config.action_mailer.default_url_options = { :host => 'localhost:3000' }
  config.action_mailer.delivery_method = :smtp
  config.action_mailer.smtp_settings = {
    :address              => "smtp.gmail.com",
    :port                 => "587",
    :domain               => "gmail.com",
    :user_name            => "<my gmail username> ",
    :password             => "<my gmail password>",
    :authentication       => "plain",
    :enable_starttls_auto => true
}
```

Note there is no delivery method specified in the first case because
sendmail is assumed by default. With these settings, devise seems to do its
stuff, although its email templates may need modification later. New
registrations and password resetting seem to work fine.

The next aspect is sample recepts and updates. For these we create a Sample
mailer with two templates:

```
rails g mailer sample_mailer sample_receipt sample_update
```

This generates a file `app/mailers/sample_mailer.rb`. This is edited to
contain the following:

```
class SampleMailer < ActionMailer::Base
  default :from => "Crystallography Service <ncrystal@ncl.ac.uk>"

  # Subject can be set in your I18n file at config/locales/en.yml
  # with the following lookup:
  #
  #   en.sample.sample_receipt.subject
  #
  def sample_receipt(sample)
    @sample = sample
    mail(:to => "#{sample.user.firstname} #{sample.user.lastname} <#{sample.user.email}>", :subject => "Crystallography Service: Analysis Request Acknowledgement")
  end

  # Subject can be set in your I18n file at config/locales/en.yml
  # with the following lookup:
  #
  #   en.sample.sample_update.subject
  #
  def sample_update(sample)

    mail(:to => "#{sample.user.firstname} #{sample.user.lastname} <#{sample.user.email}>", :subject => "Crystallography Service: Sample Status Update Notification")
  end
end
```

The line with `default` sets the default `from` address. There are two
methods, one of which sends a confirmation email when a sample is first
submitted. The second (incomplete) method will send an email when a sample
status changes. These methods can now be used by the samples controller
as here in the case of the `create` action:

```
  def create
    # @sample = Sample.new(params[:sample])
    @sample = current_user.samples.build params[:sample]
    if @sample.save
      SampleMailer.sample_receipt(@sample).deliver
      redirect_to @sample, :notice => "Sample request registered. You will receive a receipt and confirmation via email."
    else
      render :action => 'new'
    end
  end
```

Note that the controller calls the `sample_receipt` method defined in
the `app/mailers/sample_mailer.rb` file. The `@sample` variable is
passed on to the appropriate view which is constructed prior to the
sending of the email.

The views are in the directory `app/views/sample_mailer`
in the files `sample_receipt.text.erb` and `sample_update.text.erb`. They
are designed as templates for text emails. For html you create files
with similar names but `text` replaced by `html`. A first attempt at this
produced the following template for `sample_receipt.html.erb`:

```
<p>
Dear <%="#{@sample.user.firstname} #{@sample.user.lastname}"%>
<p>
<p>
your sample analysis request has been received. Please download a
receipt using the link below. There is a tear-off slip at the bottom
of the receipt which you should attach to your sample.
You will be informed via email of any
changes in the status of your sample analysis.
<p>
<p>
<%= link_to "Analysis Request Receipt", "#{sample_url(@sample, :host => 'localhost:3000')}.pdf" %>
</p>
<p>
Newcastle Crystallography Service
</p>
```

One final thing which is useful (maybe essential) for development work.
With many users you don't want to send emails to the real addresses - it
would be nice if all emails to users could go to a single convenient address
in development. This functionality can be provided by interceptors.
To set things up, first create a file in the top-level `lib` directory
called (say) `development_mail_interceptor.rb`. The contents of this
file are:

```
class DevelopmentMailInterceptor
  def self.delivering_email(message)
    message.subject = "[#{message.to}] #{message.subject}"
    message.to = "jphagon@gmail.com"
  end
end
```

This code sets up the required behaviour, redirecting all emails to
`jphagon@gmail.com`. 
Next we need to register the interceptor in an initializer file 
which we can do by creating a file called (say) `setup_mail.rb` in
the `config/initializers` directory.

```
require 'development_mail_interceptor' # put this in the lib directory
ActionMailer::Base.register_interceptor(DevelopmentMailInterceptor) if Rails.env.development?
```

Generating Sample Data
======================
Use Faker to generate a large number of users and samples so that we can
test (among other things) pagination of sample listings etc.
Faker is installed via bundle in the usual way by placing the instruction
`gem 'faker'` in the development group of the Gemfile. Then need to
add the populate instructions in a rake tasks file which I've called
`sample_data.rake`. This file is placed in `lib/tasks`.
